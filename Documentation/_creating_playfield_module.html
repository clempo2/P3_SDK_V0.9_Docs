<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P3-SDK: Creating Your Playfield Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">P3-SDK<span id="projectnumber">&#160;0.9</span>
   </div>
   <div id="projectbrief">P3 Software Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('_creating_playfield_module.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Creating Your Playfield Module </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__docs_240_01_creating_playfield_module"></a></p>
<h1 class="doxsection"><a class="anchor" id="CreatingPlayfieldModuleIntroduction"></a>
Introduction</h1>
<p>Upper playfield modules contain all of the playfield features beyond the row of scoops on the P3 playfield and in some cases additional features that mount elsewhere, such as over the lower playfield or on top of the bbackbox (eg. a topper). New game developers can optionally develop new upper playfield modules for their game, or they can write their game to work with one or more existing playfield modules. Creating a new playfield module involves both creating the physical module and also creating a "module driver" so software running on the P3 knows how to interface to the playfield module's features.</p>
<h1 class="doxsection"><a class="anchor" id="PlayfieldModuleMechanicals"></a>
Mechanical Specs</h1>
<p>Multimorphic publishes mechanical specifications and some CAD files useful for creating the physical playfield module. <br  />
</p>
<p>This includes:</p>
<ul>
<li>The playfield surface and backpanel</li>
<li>Physical mechanisms (ramps, loops, toys, coils, LEDs, switches, etc)</li>
<li>Launch tubes for interfacing to the P3's ball trough / launching system</li>
<li>Templates for artwork (cabinet, backbox, apron, side target, slingshot, translite)</li>
</ul>
<p>To access the hardware specifications, first create an account on the Multimorphic's <a href="https://www.multimorphic.com/account/">Account Page</a>. Then click over to the Support page -&gt; Maintenance, troubleshooting, technical manuals, how-to videos, tutorials, etc. -&gt; 3rd-Party Development Kit.</p>
<p>For more details on the mechanicals, please contact <a href="mailto:support@multimorphic.com">support@multimorphic.com</a></p>
<h1 class="doxsection"><a class="anchor" id="PlayfieldModuleElectronics"></a>
Electronic Specs</h1>
<p>In order to communicate with the rest of the P3 system, playfield modules generally need SW-16 switch boards that keep track of the states of every switch on the playfield, and they need PD-16 and/or PD-LED driver boards to control coils/DC-motors/magnets and LED/Servos/Steppers, respectively.</p>
<p>For more details on the electronics, please contact <a href="mailto:support@multimorphic.com">support@multimorphic.com</a></p>
<h1 class="doxsection"><a class="anchor" id="PlayfieldModuleID"></a>
Playfield Module Identifier</h1>
<p>Every upper playfield module design has a unique identifier (string) that is read by the P3 at startup. This identifier is assigned by Multimorphic. To request an identifier for a new module, contact <a href="mailto:support@multimorphic.com">support@multimorphic.com</a>. That identifier will then be used in a number of places to help inform the P3 when a specific module is installed and to tell the P3 what files to load to understand how an app can interact with the module.</p>
<h1 class="doxsection"><a class="anchor" id="PlayfieldModuleUSBDevice"></a>
Playfield Module USB Device</h1>
<p>To identify itself to the P3 machine when installed, playfield modules need a USB storage device with specific contents, including an identification certificate provided by Multimorphic. Please contact <a href="mailto:support@multimorphic.com">support@multimorphic.com</a> for more information about the USB device.</p>
<h1 class="doxsection"><a class="anchor" id="PlayfieldModuleDriver"></a>
Playfield Module Driver</h1>
<p>A playfield module driver includes a number of files that allow apps on the P3 to interact with features on the playfield module. It is installed in the ~/.multimorphic/P3/ModuleDrivers/&lt;module_identifier&gt;/&lt;module_driver_version&gt;/ folder. When installing a module driver package on the P3, System Manager will ensure the files are installed in the right place. For simulating on a development machine, the module driver files should be installed in the ~/.multimorphic/P3/ModuleDrivers/&lt;module_identifier&gt;/&lt;module_driver_version&gt;/ folder.</p>
<p>On Windows development machines, ~/ refers to "%HOMEDRIVE%%HOMEPATH%". To find the .multimorphic directory on a Windows machine, open up a command line and type cd /d "%HOMEDRIVE%%HOMEPATH%". When writing your game app, you simply define the ModuleID field in AppConfig.json, and the framework will handle the rest, loading the appropriate hardware configuration file, if it finds a matching module driver.</p>
<p>The files a module developer should create and include in the module driver are:</p><ul>
<li>&lt;module_identifier&gt;.json : The Module Definition File (required)</li>
<li>&lt;module_identifier&gt;.dll : The compiled source code for controlling the module's features (required if the module has any features with switches or drivers)</li>
<li>&lt;diagnostics-assets-file&gt; : A Unity asset bundle that includes the Unity assets to be displayed/controlled when the Playfield Module option is selected in the P3's Diagnostics application for testing playfield module features.</li>
<li>UsageInstructions.txt : One or more files to help app developers understand how to interface to various features included in the module driver DLL.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="PlayfieldModuleDefinitionFile"></a>
Module Definition File</h2>
<p>A playfield module definition file is what tells an app some specific details of features on the playfield. These details are required to be written in the JSON format, with specific fields as described below:</p>
<p>Available Sections:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Section  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Game  </td><td class="markdownTableBodyLeft">Global parameters for the game  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Flippers  </td><td class="markdownTableBodyLeft">One entry for each device that is automatically driven by the hardware when the flipper buttons are hit  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Bumpers  </td><td class="markdownTableBodyLeft">One entry for each device that is automatically driven by the hardware when the corresponding switch is hit  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">UpperDisplay  </td><td class="markdownTableBodyLeft">Information on the presence and resolution of the mini-display on the playfield module  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TroughLaunchers  </td><td class="markdownTableBodyLeft">Information required by game applications to configure trough-based ball launchers.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Switches  </td><td class="markdownTableBodyLeft">One entry for each switch  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Coils  </td><td class="markdownTableBodyLeft">One entry for each coil  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">LEDs  </td><td class="markdownTableBodyLeft">One entry for each LED  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">LEDStrings  </td><td class="markdownTableBodyLeft">One entry for each WS2812-compatible string of LEDs  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Servos  </td><td class="markdownTableBodyLeft">One entry for each servo motor  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Steppers  </td><td class="markdownTableBodyLeft">One entry for each stepper motor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">BallPaths  </td><td class="markdownTableBodyLeft">One entry for each playfield-specific shot and target  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="ModuleDefinitionCoords"></a>
Coordinate System</h3>
<p>Some fields specify a position on the playfield as an array of 3 floats [x, y, z]. The coordinate system is measured in inches, where [0,0,0] is the front left corner of the playfield module at the surface of the playfield. Positive x increases towards the right of the machine. Positive y increases towards the back of the machine. Positive z increases upwards from the playing surface. This means positions over the playfield screen use negative y coordinates.</p>
<p>Example: </p><div class="fragment"><div class="line">&quot;TroughLaunchers&quot;: [</div>
<div class="line">  { </div>
<div class="line">    &quot;Name&quot;: &quot;LeftVUK&quot;,</div>
<div class="line">    &quot;VUKNumber&quot;: 3,</div>
<div class="line">    &quot;HighSwitch&quot;: &quot;vukExit3&quot;,</div>
<div class="line">    &quot;LowSwitch&quot;: &quot;vukEntrance3&quot;,</div>
<div class="line">    &quot;Bidirectional&quot;: true,</div>
<div class="line">    &quot;CustomCode&quot;: false,</div>
<div class="line">    &quot;Destination&quot;: &quot;LeftInlane&quot;,</div>
<div class="line">    &quot;EntrancePosition&quot;: [3.750,7.5,0],</div>
<div class="line">    &quot;ExitPosition&quot;: [3.750,7.5,0]</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionGame"></a>
Game Section</h3>
<p>This section describes a few global parameters:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the playfield module  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">machineType  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Must be "PDB"  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">numBalls  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">Minimum number of balls that must be installed for normal operation of apps on this module. This is informative and not strictly enforced. Installing more balls is possible. Some apps may try to compensate if fewer balls are installed, but that normally results in a degraded experience.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Game&quot;: {</div>
<div class="line">  &quot;Name&quot;: &quot;LL-EE&quot;,</div>
<div class="line">  &quot;machineType&quot;: &quot;PDB&quot;,</div>
<div class="line">  &quot;numBalls&quot;: 17</div>
<div class="line">},</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionFlippers"></a>
Flippers Section</h3>
<p>This section describes each flipper that is part of the playfield module design. Flippers are devices that are automatically driven by the hardware when the flipper buttons are hit.</p>
<p>Playfield module definition files should contain descriptions of flippers on the module itself plus the upper flippers (right above the side targets) that are safe and/or intended to be used with the module. Playfield module definition files must not contain descriptions of the lower main flippers, nor upper flippers that must remain disabled by design.</p>
<p>The Flipper definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the flipper  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SettingsPrefix  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Prefix for the GameAttributes associated with the flipper. These GameAttributes appear under "Service Menu/Settings/Mechs/Coils".  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">SwitchName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Switch name for the button used for primary activation.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SecondarySwitchName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Switch name for the button that should activate the flipper when one-handed play is enabled.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">AlternateSwitchName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Switch name for the button that should activate the flipper when the 'activate all flippers with red buttons' operator setting is active.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EOSSwitchName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the End Of Stroke Switch. Field is absent if no EOS Switch.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MainCoilName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the Coil that provides the initial stroke.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HoldCoilName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the Coil that keeps the flipper up.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Flippers&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;flipperUpR&quot;,</div>
<div class="line">    &quot;SettingPrefix&quot;: &quot;UpperRightFlipper&quot;,</div>
<div class="line">    &quot;SwitchName&quot;: &quot;buttonRight2&quot;,</div>
<div class="line">    &quot;SecondarySwitchName&quot;: &quot;buttonLeft2&quot;,</div>
<div class="line">    &quot;AlternateSwitchName&quot;: &quot;buttonRight0&quot;,</div>
<div class="line">    &quot;MainCoilName&quot;: &quot;auxRight0&quot;,</div>
<div class="line">    &quot;HoldCoilName&quot;: &quot;auxRight1&quot;</div>
<div class="line">  },</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;flipperUpL&quot;,</div>
<div class="line">    &quot;SettingPrefix&quot;: &quot;UpperLeftFlipper&quot;,</div>
<div class="line">    &quot;SwitchName&quot;: &quot;buttonLeft2&quot;,</div>
<div class="line">    &quot;SecondarySwitchName&quot;: &quot;buttonRight2&quot;,</div>
<div class="line">    &quot;AlternateSwitchName&quot;: &quot;buttonLeft0&quot;,</div>
<div class="line">    &quot;MainCoilName&quot;: &quot;auxLeft0&quot;,</div>
<div class="line">    &quot;HoldCoilName&quot;: &quot;auxLeft1&quot;</div>
<div class="line">  },</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;flipperMezzanine&quot;,</div>
<div class="line">    &quot;SettingPrefix&quot;: &quot;MezzanineFlipper&quot;,</div>
<div class="line">    &quot;SwitchName&quot;: &quot;buttonLeft2&quot;,</div>
<div class="line">    &quot;SecondarySwitchName&quot;: &quot;buttonRight2&quot;,</div>
<div class="line">    &quot;AlternateSwitchName&quot;: &quot;&quot;,</div>
<div class="line">    &quot;MainCoilName&quot;: &quot;MezFlipperMain&quot;,</div>
<div class="line">    &quot;HoldCoilName&quot;: &quot;MezFlipperHold&quot;</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><p>Note - The upper flipper coils (auxRight0, auxRight1, auxLeft0, auxLeft1) are part of the base machine definition; they must not be defined in the Playfield Module Definition File.</p>
<h3 class="doxsection"><a class="anchor" id="ModuleDefinitionBumpers"></a>
Bumpers Section</h3>
<p>This section describes each bumper. Playfield module definition files should only contain descriptions of bumpers that are part of the playfield module design. Bumpers are all devices for which the device's coil should be pulsed immediately following the activation of the device's switch. These typically include slingshots and pop bumpers.</p>
<p>The Bumper definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the bumper  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SwitchName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the Switch that activates the bumper  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CoilName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the Coil to be pulsed when the bumper activates  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SettingName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of strength setting for the bumper. The setting can be shared with other pop bumpers or independent.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">SwitchPolarity  </td><td class="markdownTableBodyLeft">bool  </td><td class="markdownTableBodyLeft">Polarity of the switch. Use true for NO switches, false for NC. Using the correct polarity will ensure the associated coil activates as quickly as possible when the ball hits the bumper.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">AllowShotgunning  </td><td class="markdownTableBodyLeft">bool  </td><td class="markdownTableBodyLeft">If true, the coil will fire on every switch event. If false, the coil won't fire a second time due to switch events happening within the next 64ms.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Bumpers&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;popBumper&quot;,</div>
<div class="line">    &quot;SwitchName&quot;: &quot;popBumper&quot;,</div>
<div class="line">    &quot;CoilName&quot;: &quot;popBumper&quot;,</div>
<div class="line">    &quot;SettingName&quot;: &quot;PopBumperPulseTime&quot;,</div>
<div class="line">    &quot;SwitchPolarity&quot;: true,</div>
<div class="line">    &quot;AllowShotgunning&quot;: true</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionUpperDisplay"></a>
UpperDisplay Section</h3>
<p>This section describes the mini-display on the playfield module, when applicable. For example, Lexy Lightspeed - Escape From Earth and Cannon Lagoon have a mini-display, but Heist does not.</p>
<p>The UpperDisplay section includes the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Present  </td><td class="markdownTableBodyLeft">bool  </td><td class="markdownTableBodyLeft">true when the module has a mini-display, false otherwise  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Width  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">Horizontal resolution of the mini-display, when applicable  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Height  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">Vertical resolution of the mini-display, when applicable  </td></tr>
</table>
<p>Example 1: </p><div class="fragment"><div class="line">&quot;UpperDisplay&quot;: {</div>
<div class="line">  &quot;Present&quot;: true,</div>
<div class="line">  &quot;Width&quot;: 800,</div>
<div class="line">  &quot;Height&quot;: 480</div>
<div class="line">},</div>
</div><!-- fragment --><p>Example 2: </p><div class="fragment"><div class="line">&quot;UpperDisplay&quot;: {</div>
<div class="line">  &quot;Present&quot;: false</div>
<div class="line">},</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionTroughLaunchers"></a>
TroughLaunchers Section</h3>
<p>This section describes each TroughLauncher, which is a mechanism used to launch a ball from the P3's trough out to the playfield. The mechanisms usually just include a tube that mates with the P3's trough and one or two switches. Tubes are available from Multimorphic for each available trough launch position, and they can be ordered with or without switches. They can also be ordered with a ball-stopper, which keeps balls from rolling past that launch position in the trough. The leftmost tube installed on a playfield should contain the ball-stopper.</p>
<p>The TroughLauncher definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the launcher (not used by any code)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">VUKNumber  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">Trough position for the launcher. There are 8 physical positions from left to right (0-7). 4 is the center one. There is no available launcher on the right end of the playfield. See the note below for launchers &gt;= 8.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HighSwitch  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the higher of two possible switches. Required for all TroughLaunchers. For tubes used only for launching (Bidirectional=false), this switch is usually installed after the make point on the ball delivery system so that a switch event means a ball successfully exited the tube. The make point is the point at which the ball can no longer fall back into the tube.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">LowSwitch  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the lower of the two possible switches. Required for Bidirectional=true TroughLaunchers. Not used for Bidirectional=false TroughLaunchers. In Bidirectional configurations, the software uses the LowSwitch to determine when a ball is going up the tube and when a ball is coming down the tube.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Bidirectional  </td><td class="markdownTableBodyLeft">bool  </td><td class="markdownTableBodyLeft">true for bidirectional operation (requires both HighSwitch and LowSwitch definitions). false for unidirectional operation (requires HighSwitch only).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">CustomCode  </td><td class="markdownTableBodyLeft">bool  </td><td class="markdownTableBodyLeft">true for complex launching mechanisms that require custom code to get the ball into play (eg. multi-stage launchers or launchers with diverters).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Destination  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Identifies the destination of the ball launch. See the available values below.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EntrancePosition  </td><td class="markdownTableBodyLeft">float[]  </td><td class="markdownTableBodyLeft">Geographic coordinate of the hole entrance, in inches: [x, y, z]. For bidirectional TroughLaunchers only.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ExitPosition  </td><td class="markdownTableBodyLeft">float[]  </td><td class="markdownTableBodyLeft">Geographic coordinate where the ball enters the playfield, in inches: [x, y, z]. This could be right above the TroughLauncher (like in CL) or at an inlane (like in LL-EE).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;TroughLaunchers&quot;: [</div>
<div class="line">  { </div>
<div class="line">    &quot;Name&quot;: &quot;LeftVUK&quot;,</div>
<div class="line">    &quot;VUKNumber&quot;: 3,</div>
<div class="line">    &quot;HighSwitch&quot;: &quot;vukExit3&quot;,</div>
<div class="line">    &quot;LowSwitch&quot;: &quot;vukEntrance3&quot;,</div>
<div class="line">    &quot;Bidirectional&quot;: true,</div>
<div class="line">    &quot;CustomCode&quot;: false,</div>
<div class="line">    &quot;Destination&quot;: &quot;LeftInlane&quot;,</div>
<div class="line">    &quot;EntrancePosition&quot;: [3.750,7.5,0],</div>
<div class="line">    &quot;ExitPosition&quot;: [3.750,7.5,0]</div>
<div class="line">  },       </div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;RightVUK&quot;,</div>
<div class="line">    &quot;VUKNumber&quot;: 5,</div>
<div class="line">    &quot;HighSwitch&quot;: &quot;vukExit5&quot;,</div>
<div class="line">    &quot;LowSwitch&quot;: null,</div>
<div class="line">    &quot;Bidirectional&quot;: false,</div>
<div class="line">    &quot;Destination&quot;: &quot;RightInlane&quot;,</div>
<div class="line">    &quot;EntrancePosition&quot;: [14.374,7.5,0],</div>
<div class="line">    &quot;ExitPosition&quot;: [14.374,7.5,0]</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><p>The TroughLauncher Destination field is used by apps that don't know specific details about the playfield (like apps written to work with any playfield module) to be able to request launches to useful destinations. Options include:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Destination  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"LeftInlane"  </td><td class="markdownTableBodyLeft">Feeds the wireform going to the left inlane.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">"RightInlane"  </td><td class="markdownTableBodyLeft">Feeds the wireform going to the right inlane.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"LowerPlayfield"  </td><td class="markdownTableBodyLeft">Ejected balls will find their way to the lower playfield, even if walls/scoops are raised.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">"UpperPlayfield"  </td><td class="markdownTableBodyLeft">Ejected balls would get stuck behind any walls/scoops that are raised.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"StagingArea"  </td><td class="markdownTableBodyLeft">Ejected balls go into another position that isn't in-play on the playfield.  </td></tr>
</table>
<p>These options are defined in Multimorphic.P3.Mechs.LaunchDestination</p>
<p>Note - it is possible to define multiple TroughLaunchers for the same tube for cases where a launch tube feeds a diverter or something else that can alter the movement of the ball. To do this, add 8 to the VUKNumber for each additional definition. TroughLaunchers that share the same tube must have identical values for the HighSwitch, LowSwitch, and Bidirectional fields. Balls detected as coming down a bidirectional tube will always get detected as coming down the actual/physical tube number (0-7).</p>
<p>Example: </p><div class="fragment"><div class="line">&quot;TroughLaunchers&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;Name&quot;: &quot;RightVUK&quot;,</div>
<div class="line">      &quot;VUKNumber&quot;: 6,</div>
<div class="line">      &quot;HighSwitch&quot;: &quot;vukExit6&quot;,</div>
<div class="line">      &quot;LowSwitch&quot;: &quot;vukEntrance6&quot;,</div>
<div class="line">      &quot;Bidirectional&quot;: true,</div>
<div class="line">      &quot;CustomCode&quot;: false,</div>
<div class="line">      &quot;Destination&quot;: &quot;StagingArea&quot;</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;Name&quot;: &quot;RightVUKToLeftInlane&quot;,</div>
<div class="line">      &quot;VUKNumber&quot;: 14,</div>
<div class="line">      &quot;HighSwitch&quot;: &quot;vukExit6&quot;,</div>
<div class="line">      &quot;LowSwitch&quot;: &quot;vukEntrance6&quot;,</div>
<div class="line">      &quot;Bidirectional&quot;: true,</div>
<div class="line">      &quot;CustomCode&quot;: true,</div>
<div class="line">      &quot;Destination&quot;: &quot;LeftInlane&quot;</div>
<div class="line">    }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionSwitches"></a>
Switches Section</h3>
<p>This section describes each switch on the playfield module. Switches are wired to Multimorphic switch boards (available from Multimorphic). The first board must be set to address 4. Additional switch boards can be added, with addresses &gt; 4. Each address corresponds to 16 switches. Therefore, the switch connected to the first input on address 4 is assigned number (16 * 4) = 64.</p>
<p>The Switch definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the switch. This is the name software will use to read the switch.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Type  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">"NC" for normally closed switches (switches that pull the switch board input to ground by default. "NO" for normally open switches.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Number  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Value of 16*board address + board input number, converted to string.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Label  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">User-friendly string for displaying the switch name on graphics.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">DebounceRequired  </td><td class="markdownTableBodyLeft">bool  </td><td class="markdownTableBodyLeft">false turns off debouncing, saving 1-2ms. Generally optos do not need debouncing, but that depends on the scenario. Default is true.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Location  </td><td class="markdownTableBodyLeft">float[]  </td><td class="markdownTableBodyLeft">Geographic coordinate of the switch, in inches: [x, y, z].  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Switches&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;leftRamp&quot;,</div>
<div class="line">    &quot;Type&quot;: &quot;NC&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;68&quot;,</div>
<div class="line">    &quot;Label&quot;: &quot;Left Ramp&quot;</div>
<div class="line">  },</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;innerLoopRight&quot;,</div>
<div class="line">    &quot;Type&quot;: &quot;NC&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;69&quot;,</div>
<div class="line">    &quot;Label&quot;: &quot;Inner Loop Right&quot;,</div>
<div class="line">    &quot;DebounceRequired&quot;: false</div>
<div class="line">  },</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;popBumber&quot;,</div>
<div class="line">    &quot;Type&quot;: &quot;NO&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;93&quot;,</div>
<div class="line">    &quot;Label&quot;: &quot;Pop Bumper&quot;</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionCoils"></a>
Coils Section</h3>
<p>This section describes each coil on the playfield module. Coils are wired to Multimorphic driver boards (available from Multimorphic). The first board must be set to address 6. Any number of additional driver boards can be added, with board addresses &gt; 6. Each address corresponds to 16 coils (or other devices), configured as two banks of 8 (bank 0 and bank 1).</p>
<p>The Coil definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the coil. This is the name software will use to drive the coil.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Number  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">This is a formatted string Ax-By-z, where x is the board address, y is the bank number, and z is the output number.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Label  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">User-friendly string for displaying the coil name on graphics.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">PulseTime  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">Default pulse length in milliseconds. Software can override this.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Coils&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;popBumper&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;A6-B0-2&quot;,</div>
<div class="line">    &quot;Label&quot;: &quot;Pop Bumper&quot;,</div>
<div class="line">    &quot;PulseTime&quot;: 8</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionLEDs"></a>
LEDs Section</h3>
<p>This section describes each LED on the playfield module. LEDs are wired to Multimorphic PD-LED boards (available from Multimorphic). The first board must be set to address 9. Any number of additional PD-LED boards can be added, with board addresses &gt; 9. Each address corresponds to 84 direct-wired LEDs (or 28 RGB LEDs) or up to 2048 RGB LEDs in one or more serial strings.</p>
<p>The LED definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">For a single RBG LED driven by a PD-LED RGB output or an LED string segment consisting of a single RGB LED, this is the name software will use to drive the LED.<br  />
 <br  />
 or<br  />
 <br  />
 For an LED string segment consisting of more than one RGB LED, this is the baseName without the index suffix, the full name including the index suffix is what the software will use to drive each LED.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Polarity  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">"True" if the LED turns on by controlling the anode. "False" if the LED turns on by controlling the cathode.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Number  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">For a single RGB LED driven by a PD-LED RGB output:<br  />
 This is a formatted string "Ax-Rr-Gg-Bb", where x is the board address, r is the output connected to an RGB's red input, g for the green output, and b for the blue output. The software only provisions RGB LEDs, but the hardware supports individual LEDs. If your module contains individual LEDs, you can control them in software by accessing only that color of the RBG LED defined here.<br  />
 <br  />
 or<br  />
 <br  />
 For an LED string segment consisting of a single RGB LED:<br  />
 This is a formatted string "Ax:Sa", where x is the board address, and a is the LED string index. The name of the LED is taken as given without appending an index.<br  />
 <br  />
 or<br  />
 <br  />
 For an LED string segment consisting of more than one RGB LED:<br  />
 This is a formatted string "Ax:Sa-Sb", where x is the board address, a is the starting LED string index, and b is the ending LED string index. This LED definition will be replaced by a set of LED definitions, baseName0,...,baseName{b-a}, with one definition for each RGB LED that composes this LED string segment. The application will never see the LED definition with just the baseName.<br  />
 <br  />
 Note: if using an LED string, your Module Definition File must also include an LEDStrings section to describe how the strings themselves should be defined.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MaxBrightness  </td><td class="markdownTableBodyLeft">double  </td><td class="markdownTableBodyLeft">A value between 0 and 1. Limits the available power range for an LED. This value is multiplied against the desired LED color value before the resulting value is sent to hardware.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Label  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">User-friendly string for displaying the LED name on graphics.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Location  </td><td class="markdownTableBodyLeft">float[]  </td><td class="markdownTableBodyLeft">Geographic coordinate of the LED, in inches: [x, y, z].  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MapIntoSpecialLEDFeatures  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Used for individually controlled features mapped to a PD-LED output, such as a motor control line. When "True", this item won't appear in the P3's LED Diagnostics.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">DependentSwitch  </td><td class="markdownTableBodyLeft">object  </td><td class="markdownTableBodyLeft">Ensures the switch is the desired state at startup. If not, this item will be ignored by the configuration logic. This a JSON object of the form: {"SwitchName": string, "SwitchActive": bool}. For example {"SwitchName": "servoWS", "SwitchActive": false}  </td></tr>
</table>
<p>The LED definitions created from an LED string segment will all share the same location after reading the module definition file. The module driver must include code to assign the correct locations after the fact, otherwise the LED simulator will display these LEDs all on top of each other, and games will not be able to compute light show sweeps correctly.</p>
<p>Example: </p><div class="fragment"><div class="line">&quot;LEDs&quot;: [</div>
<div class="line">   {</div>
<div class="line">     &quot;Name&quot;: &quot;flasherShip&quot;,</div>
<div class="line">     &quot;Polarity&quot;: &quot;True&quot;, </div>
<div class="line">     &quot;Number&quot;: &quot;A9-R0-G1-B2&quot;, </div>
<div class="line">     &quot;Label&quot;: &quot;Flasher Ship&quot;</div>
<div class="line">   }, </div>
<div class="line">   {</div>
<div class="line">     &quot;Name&quot;: &quot;topTarget0&quot;,</div>
<div class="line">     &quot;Polarity&quot;: &quot;False&quot;,</div>
<div class="line">     &quot;Number&quot;: &quot;A9-R60-G61-B62&quot;,</div>
<div class="line">     &quot;Label&quot;: &quot;Top 0&quot;</div>
<div class="line">   },</div>
<div class="line">   {</div>
<div class="line">     &quot;Name&quot;: &quot;CafeSign&quot;,</div>
<div class="line">     &quot;Polarity&quot;: &quot;True&quot;,</div>
<div class="line">     &quot;Number&quot;: &quot;A9:S100-S104&quot;,</div>
<div class="line">     &quot;Label&quot;: &quot;Cafe Sign&quot;,</div>
<div class="line">     &quot;Location&quot;: [2,14,5]</div>
<div class="line">   },</div>
<div class="line">   {</div>
<div class="line">     &quot;Name&quot;: &quot;FoodL&quot;,</div>
<div class="line">     &quot;Polarity&quot;: &quot;True&quot;,</div>
<div class="line">     &quot;Number&quot;: &quot;A9:S105&quot;,</div>
<div class="line">     &quot;Label&quot;: &quot;Food Left&quot;,</div>
<div class="line">     &quot;Location&quot;: [3.25,14,4]</div>
<div class="line">   }</div>
<div class="line"> ],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionLEDStrings"></a>
LEDStrings Section</h3>
<p>This section describes WS2812-compatible strings of LEDs, each driven by a single string output from a Multimorphic PD-LED boards (available from Multimorphic). The StartingIndex and EndingIndex are RGB indices. The first LED element will be at 3*StartingIndex and the last LED element will be at 3*EndingIndex+2.</p>
<p>The LEDString definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the LEDString. Usually something generic like "Board 9 - String 0"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Number  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">This is a formatted string Ax-WS2812-a, where x is the board address and a is the string output (usually 0 to 2).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Polarity  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">"True" for LEDs that turn on with a high control signal. "False" for LEDs that turn on with a low control signal.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">RGBOrder  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Typically "GRB" for a WS2812 string  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">StartingIndex  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">The starting LED index for the first color of the first RGB LED in a string, as referenced in the PD-LED's LED indexing.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EndingIndex  </td><td class="markdownTableBodyLeft">int  </td><td class="markdownTableBodyLeft">The ending LED index for the last color of the last RGB LED in a string, as referenced in the PD-LED's LED indexing.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Label  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">User-friendly string for displaying the LEDString name on graphics.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;LEDStrings&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;Board 9 - String 0&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;A9-WS2812-0&quot;,</div>
<div class="line">    &quot;RGBOrder&quot;: &quot;GRB&quot;,</div>
<div class="line">    &quot;StartingIndex&quot;: 100,</div>
<div class="line">    &quot;EndingIndex&quot;: 199,</div>
<div class="line">    &quot;Label&quot;: &quot;Board 9 - String 0&quot;</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionServos"></a>
Servos Section</h3>
<p>This section describes each servo on the playfield module that is wired to a Multimorphic PD-LED board (available from Multimorphic). Each PD-LED board can control the operation of up to 12 servos.</p>
<p>The servo definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the servo motor. This is the name software will use to drive the motor.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Number  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">This is a formatted string Ax-y, where x is the address of the PD-LED board, and y is the index of the servo on the board (0-11, refer to the PD-LED board specifications).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Label  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">User-friendly string for displaying the motor name on graphics.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Servos&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;rampDiverter&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;A9-0&quot;,</div>
<div class="line">    &quot;Label&quot;: &quot;Ramp Diverter&quot;</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="ModuleDefinitionSteppers"></a>
Steppers Section</h3>
<p>This section describes each stepper motor on the playfield module that is wired to a Multimorphic PD-LED board (available from Multimorphic). Each PD-LED board can control the operation of up to 2 stepper motors, connected through a separate stepper motor driver circuit.</p>
<p>The stepper motor definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the stepper motor. This is the name software will use to drive the motor.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Number  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">This is a formatted string Ax-y, where x is the address of the PD-LED board, and y is the index of the stepper motor on the board (0 or 1, refer to the PD-LED board specifications).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Label  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">User-friendly string for displaying the motor name on graphics.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Comma-separated list of tags the software can optionally use.  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;Steppers&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;movingToy&quot;,</div>
<div class="line">    &quot;Number&quot;: &quot;A9-0&quot;,</div>
<div class="line">    &quot;Label&quot;: &quot;Moving Toy&quot;</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="BallPaths"></a>
BallPaths Section</h3>
<p>This section describes definitions of BallPaths, which allow a game application to make use of playfield-specific shots and targets even if the application has no specific knowledge about which playfield is installed in the P3 at run-time. This section is therefore REQUIRED in all module drivers for all shots that aren't simply entrances into TroughLaunchers that aren't handled by a module driver. Said another way, if a shot does not go into a TroughLauncher or if a shot goes into a TroughLauncher and the module driver handles that entrance and posts other events, the shot needs to be defined here.</p>
<p>The events defined in BallPaths must be implemented in the associated module driver code. The module driver is what determines that a shot starts or completes, and then it posts the associated Started and Completed events defined in the BallPath definitions.</p>
<p>The BallPath definitions include the following fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Type&#160;&#160;&#160;&#160;&#160;&#160;  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Name  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Name of the BallPath. This is the name software will use to reference the BallPath.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Tags  </td><td class="markdownTableBodyLeft">string[]  </td><td class="markdownTableBodyLeft">Array of tags the software can optionally use.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ExitType  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">String name of the associated Multimorphic.NetProcMachine.Config.BallPathExitType enum. See below for the available values.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EntranceName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">String name of the entrance into the shot (can be anything)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ExitName  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">String name of the exit of the shot (can be anything)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">StartedEvent  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Event name that's posted when the shot is started (ie. a ball hits the first switch in a loop)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CompletedEvent  </td><td class="markdownTableBodyLeft">string  </td><td class="markdownTableBodyLeft">Event name that's posted when the shot is completed (ie. a ball completes a loop)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EntrancePosition  </td><td class="markdownTableBodyLeft">float[]  </td><td class="markdownTableBodyLeft">Geographic coordinate of the shot entrance, in inches: [x, y, z]  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ExitPosition  </td><td class="markdownTableBodyLeft">float[]  </td><td class="markdownTableBodyLeft">Geographic coordinate of the shot exit, in inches: [x, y, z]  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">EntranceLEDs  </td><td class="markdownTableBodyLeft">string[][]  </td><td class="markdownTableBodyLeft">Array of arrays of LED segments. The first dimension is typically for parallel arrays, like the inside and outside strings of LEDs on a Cosmic Cart Racing ramp. The second dimension is the sequence of LEDs, starting closest to the shot entrance. An LED segment can either be an LED name denoting an individual LED, or a formatted string basenameX-Y denoting an LED string segment, where basename is the LED name without an index, X is the starting index and Y is the ending index, inclusive. The SDK will replace basenameX-Y by splicing in its place the sequence of LED names basenameX,...,basenameY. The application will never see the basenameX-Y notation. If no LEDs are associated with the shot, use [[""]].  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ExitLEDs  </td><td class="markdownTableBodyLeft">string[][]  </td><td class="markdownTableBodyLeft">Array of arrays of LED segments. The first dimension is typically for parallel arrays, like the inside and outside strings of LEDs on a Cosmic Cart Racing ramp. The second dimension is the sequence of LEDs, starting closest to the shot exit. An LED segment can either be an LED name denoting an individual LED, or a formatted string basenameX-Y denoting an LED string segment, where basename is the LED name without an index, X is the starting index and Y is the ending index, inclusive. The SDK will replace basenameX-Y by splicing in its place the sequence of LED names basenameX,...,basenameY. The application will never see the basenameX-Y notation. If no LEDs are associated with the shot, use [[""]].  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">&quot;BallPaths&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;Name&quot;: &quot;LeftLoop&quot;,</div>
<div class="line">    &quot;Tags&quot;: [&quot;Loop&quot;,&quot;Passthrough&quot;,&quot;Default&quot;],</div>
<div class="line">    &quot;ExitType&quot;: &quot;PlayfieldLocation&quot;,</div>
<div class="line">    &quot;EntranceName&quot;: &quot;LeftLoop&quot;,</div>
<div class="line">    &quot;ExitName&quot;: &quot;Pops&quot;,</div>
<div class="line">    &quot;StartedEvent&quot;: &quot;Evt_LeftLoopStarted&quot;,</div>
<div class="line">    &quot;CompletedEvent&quot;: &quot;Evt_LeftLoopHit&quot;,</div>
<div class="line">    &quot;EntrancePosition&quot;: [2,0,0],</div>
<div class="line">    &quot;ExitPosition&quot;: [10,15,0],</div>
<div class="line">    &quot;EntranceLEDs&quot;: [[&quot;LeftLoopInner0-2&quot;],[&quot;LeftLoopOuter0-2&quot;]],</div>
<div class="line">    &quot;ExitLEDs&quot;: [[&quot;&quot;]]</div>
<div class="line">  }</div>
<div class="line">],</div>
</div><!-- fragment --><p>In the example, the EntranceLEDs will be expanded into: </p><div class="fragment"><div class="line">&quot;EntranceLEDs&quot;: [[&quot;LeftLoopInner0&quot;,&quot;LeftLoopInner1&quot;,&quot;LeftLoopInner2&quot;],[&quot;LeftLoopOuter0&quot;,&quot;LeftLoopOuter1&quot;,&quot;LeftLoopOuter2&quot;]],</div>
</div><!-- fragment --><p>The ExitType describes what happens to the ball when the BallPath is completed. The options are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">ExitType  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Undefined  </td><td class="markdownTableBodyLeft">Reserved for use by the module driver, typically for error handling. This is not a user-makeable shot. Module agnostic games should ignore this BallPath.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Other  </td><td class="markdownTableBodyLeft">Choose this when none of the other options apply  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">PlayfieldLocation  </td><td class="markdownTableBodyLeft">Ball remains in play somewhere on the playfield  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Hole  </td><td class="markdownTableBodyLeft">Ball falls into the trough and is no longer in play  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Lock  </td><td class="markdownTableBodyLeft">Ball enters a physical lock and is no longer in play  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">TemporaryLock  </td><td class="markdownTableBodyLeft">Ball may take a while to exit, but remains in play, for example a pop area.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Target  </td><td class="markdownTableBodyLeft">Ball activates a Switch and remains in play  </td></tr>
</table>
<p>Suggested Tags to choose from: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Tag  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Default  </td><td class="markdownTableBodyLeft">This dynamic BallPath is active by default when the application starts.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Hole  </td><td class="markdownTableBodyLeft">The ball enters a hole when completing this BallPath.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Inaccessible  </td><td class="markdownTableBodyLeft">This BallPath is used to reposition a mech so that the ball can no longer enter the entrance. The Started and Completed events will never be fired.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Lock  </td><td class="markdownTableBodyLeft">The ball enters a physical lock when completing this BallPath.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Loop  </td><td class="markdownTableBodyLeft">This BallPath is an orbit.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Passthrough  </td><td class="markdownTableBodyLeft">The ball remains in play and is free to move after completing the BallPath, without intervention from the application.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Ramp  </td><td class="markdownTableBodyLeft">This BallPath is a ramp.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Scoop  </td><td class="markdownTableBodyLeft">The ball enters a scoop when completing this BallPath.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Spinner  </td><td class="markdownTableBodyLeft">This BallPath may complete multiple times for a single shot. The application might choose to implement a cool down period to ignore the subsequent events if it wants to count the shot only once.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Static  </td><td class="markdownTableBodyLeft">This BallPath does not change and is always available (should be the only one with this entrance name).  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Target  </td><td class="markdownTableBodyLeft">This BallPath is a Target.  </td></tr>
</table>
<p>Some conventions to keep in mind when designing your BallPaths:</p><ul>
<li>Name is PascalCase as &lt;EntranceName&gt;To&lt;ExitName&gt; when EntranceName != ExitName.</li>
<li>Name is PascalCase as &lt;EntranceName&gt; when ExitName == EntranceName (typically only true for Hole and Targets).</li>
<li>EntranceName and ExitName are also PascalCase and they are not necessarily Switch names.</li>
<li>An EntranceName (or ExitName) defines a consistent set of switches/criteria (i.e., two paths cannot have the same EntranceName if the switches/state are not identical).</li>
<li>StartedEvent is Evt_ShotStarted_&lt;EntranceName&gt;, since the module driver probably does not know exactly which path has started, dynamic BallPaths sharing the same EntranceName also share the same StartedEvent value.</li>
<li>CompletedEvent is Evt_ShotMade_&lt;BallPathName&gt;</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="ModuleDefinitionExample"></a>
Example Module Definition Files</h2>
<p>The development kit includes a number of existing module drivers so that developers can create new apps that work with those modules. Each has a module definition file that can serve as an example.</p>
<h2 class="doxsection"><a class="anchor" id="PlayfieldModuleDriverDLL"></a>
Developing The DLL</h2>
<p>So that game apps can interact with the features on your module, you'll likely need to develop a module driver DLL. An example module driver DLL project is included in the development kit as a Visual Studio project called SampleModuleDriver. The code generally includes handling for custom launch destinations, ball paths, event-based control of specific playfield module features, etc.</p>
<h3 class="doxsection"><a class="anchor" id="ModuleDriverDLLComponents"></a>
Main Components of a Module Driver DLL</h3>
<p>A module Driver DLL must contain:</p><ul>
<li>A ModuleController (subclass of <a class="el" href="class_multimorphic_1_1_p3_app_1_1_modes_1_1_playfield_module_1_1_playfield_module_controller.html">PlayfieldModuleController </a>)</li>
<li>One or more devices (subclasses of <a class="el" href="class_multimorphic_1_1_p3_app_1_1_modes_1_1_playfield_module_1_1_playfield_device_controller.html">PlayfieldDeviceController </a>) - This contains the logic for one or more devices on the playfield. You could implement all of your devices in a single device file or use a separate device file for each.</li>
<li>A diagnostics mode (subclass of <a class="el" href="class_multimorphic_1_1_p3_app_1_1_modes_1_1_playfield_module_1_1_playfield_module_diagnostics_mode.html">PlayfieldModuleDiagnosticsMode </a>) - This contains the logic that should execute when the Playfield Module option is selected in the P3 Diagnostics application. It includes parameters that define an asset bundle and prefab that should be added to the Diagnostics Unity hierarchy when the code is loaded. This is how Diagnostics knows how to show a graphical representation of the playfield module features; you build the Unity objects into the prefab. There's also a parameter for the name of the class that should be instantiated onto the object so that code can control those graphical elements, perhaps by responding to ModeToGUI events posted by your ModuleDriverDiagnosticsMode in response to various button presses.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="CustomLaunchCode"></a>
Custom Launch Code</h3>
<p>If a playfield module has any complex launching mechs, such as a multi-stage launcher or a launcher with a diverter, the playfield module definition file should include the "CustomCode" property on the associated TroughLauncher. Then, when a game app requests a launch out of that TroughLauncher, the platform launching code will post the ModeToMode event "Evt_CustomLaunchPrep" with a TroughLauncherDefinition param. The playfield module driver should subscribe to that event and use the TroughLauncherDefinition to see which TroughLauncher is being used for the launch. The actual launch is then paused (except for a timeout timer) until the module driver posts a response. See more details below:</p>
<p>ModeToMode events posted to module driver: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Event Name  </th><th class="markdownTableHeadLeft">Parameter Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Evt_CustomLaunchPrep  </td><td class="markdownTableBodyLeft"><a class="el" href="struct_multimorphic_1_1_p3_1_1_mechs_1_1_trough_launcher_definition.html">TroughLauncherDefinition </a>  </td><td class="markdownTableBodyLeft">Posted when beginning a custom launch, telling the module driver to do whatever it needs to do before the TroughLauncher should attempt to kick up a ball. The module driver should do what it needs to do and then post a response (see below responses) to signal it's ready for completion or to delay the launch logic from timing out.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Evt_CustomLaunchFollowUp  </td><td class="markdownTableBodyLeft"><a class="el" href="struct_multimorphic_1_1_p3_1_1_mechs_1_1_trough_launcher_definition.html">TroughLauncherDefinition </a>  </td><td class="markdownTableBodyLeft">If the module driver requested a "LaunchBallAndPostCustomFollowUp" from the TroughLauncher in its response to the Evt_CustomLaunchPrep event, the TroughLauncher will post this event after it kicks the ball up, telling the module driver to handle the ball and do any cleanup it needs to do before verifying the launch. The module driver should do what it needs to do and then post a response (see below responses) to confirm a launch success or failure.  </td></tr>
</table>
<p>Response ModeToMode events posted to module driver: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Event Name  </th><th class="markdownTableHeadLeft">Parameter Type  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Evt_CustomLaunchPrepComplete  </td><td class="markdownTableBodyLeft">Multimorphic.P3.Mechs.CustomLaunchResponse enum  </td><td class="markdownTableBodyLeft">When responding to an Evt_CustomLaunchPrep event, the module driver should indicate when the TroughLauncher should either LaunchBall or LaunchBallAndPostCustomFollowup (in the case there's more work to do after the ball is launched but before the full launch should be confirmed.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Evt_CustomLaunchStageComplete  </td><td class="markdownTableBodyLeft">Multimorphic.P3.Mechs.CustomLaunchResponse enum  </td><td class="markdownTableBodyLeft">This is used after a followup stage is completed after a ball is launched to either confirm the launch was a success or failure.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Evt_CustomLaunchResetRetryTimer  </td><td class="markdownTableBodyLeft">double  </td><td class="markdownTableBodyLeft">How much time to delay before timing out (TroughLaunchers will default to timing out a custom launch request after 2.0s)  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="ModuleDriverDiagnostics"></a>
Module Driver Diagnostics</h2>
<p>To help you make your module driver's diagnostic prefab and ensure it shows up properly, the P3 SDK includes a Unity project called SampleModuleDriverDiagnostics. It is a subset of the P3's full Diagnostics just for simulating your Playfield Module's Diagnostics routines. It includes a very simple example module driver prefab called Assets/SampleModuleDriver/SampleModuleDriver_Diags.prefab. To change this for your Module Driver, drag it into the heirarchy, modify it as desired (including renaming it), and then drag it back into a Project folder. Then, to export your asset bundle file, select the prefab in the Project window (not in the Hierarchy), and at the bottom of the inspector window, select the AssetBundle dropdown, and add a new module driver asset bundle name. Most Multimorphic module drivers call it &lt;module_identifier&gt;-diags-assets. Then to build it, click Assets -&gt; Build AssetBundles. It should then appear in Assets/AssetBundles, and you can now copy it into your module driver folder in ~/.multimorphic/P3/ModuleDrivers/&lt;module_identifier&gt;/&lt;module_driver_version&gt;/. The example is simply a counter. The text element is defined in the prefab, and the code that sends counter updates is in the module driver code.</p>
<h2 class="doxsection"><a class="anchor" id="ModuleDriverPackage"></a>
Building the Module Driver Package</h2>
<p>Follow these steps to build an installable package of your module driver for your P3. In Unity, select from the top menu Multimorphic-&gt;"Package Module For Distribution". Fill in the fields in the dialog that appears and click "Continue". An internet connection is required.</p>
<p>When the process completes, you should have a new .p3p file within your project's Packages directory. The dialog also offers the option to write a copy of the .p3p file to a USB drive during the build.</p>
<p>The .p3p file can then be installed on your P3 via a USB drive.</p>
<ul>
<li>Note: The current dev kit does not include the ability to deploy to a P3 programmatically.</li>
</ul>
<p>These are the fields presented in the packager dialog:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Field  </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Module Id  </td><td class="markdownTableBodyLeft">The module identifier  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Version  </td><td class="markdownTableBodyLeft">Module driver version (recommended format: a.b.c.d)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Files to Include  </td><td class="markdownTableBodyLeft">The path to a folder. All files within the folder will be included in the package. This folder should contain the module driver DLL, the module definition file, the diagnostics asset bundle and a document describing the module driver API to software developers.  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
