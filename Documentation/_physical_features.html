<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P3-SDK: Controlling Physical Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">P3-SDK<span id="projectnumber">&#160;0.9</span>
   </div>
   <div id="projectbrief">P3 Software Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('_physical_features.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Controlling Physical Features </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__docs_262_01_controlling_01_physical_01_features"></a></p>
<h1 class="doxsection"><a class="anchor" id="DriverActions"></a>
Drivers</h1>
<p>Drivers are used to control devices such as coils, motors, lamps, etc. Enabling drivers is as simple as calling any of the following driver helper functions: </p><div class="fragment"><div class="line">// Turn a coil on</div>
<div class="line">p3.Coils[&quot;coilName&quot;].Enable();</div>
<div class="line"> </div>
<div class="line">// Pulse a coil for 30 milliseconds.</div>
<div class="line">p3.Coils[&quot;coilName&quot;].Pulse(30);</div>
<div class="line"> </div>
<div class="line">// Turn a coil off</div>
<div class="line">p3.Coils[&quot;coilName&quot;].Disable();</div>
<div class="line"> </div>
<div class="line">// Start a duty cycle pattern of 2 milliseconds on and 8 milliseconds off.  </div>
<div class="line">// The third parameter is used to drive the coil for a number of milliseconds before starting the duty cycle pattern</div>
<div class="line">p3.Coils[&quot;coilName&quot;].Patter(2,8,0);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="KickbackExample"></a>
A Mode Example: A Kickback Mechanism</h1>
<p>Consider an example of a mode which handles a kickback mechanism. When the switch gets hit, the coil should fire. </p><div class="fragment"><div class="line">using Multimorphic.P3;</div>
<div class="line">using Multimorphic.P3App.Modes;</div>
<div class="line"> </div>
<div class="line">namespace Multimorphic.P3App.P3SA.Modes</div>
<div class="line">{</div>
<div class="line">    public class KickbackMode : P3SAGameMode</div>
<div class="line">    { </div>
<div class="line">        public KickbackMode(P3Controller controller, int priority): base(controller, priority) </div>
<div class="line">        {</div>
<div class="line">            // Add any instantiation logic here</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        public bool sw_kickback_active(Switch sw) // called when kickback switch activates </div>
<div class="line">        {</div>
<div class="line">            // Pulse the kickback solenoid for its default pulse duration.</div>
<div class="line">            p3.Coils[&quot;kickback&quot;].Pulse();</div>
<div class="line">        }</div>
<div class="line">    } </div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="TroughLaunching"></a>
Launching Balls Into Play</h1>
<p>The P3 has a complex ball trough that can launch balls into play from one of more of the 8 available launch positions. The upper plafield module (<a class="el" href="_creating_playfield_module.html">Creating Your Playfield Module</a>) being used with the app connects ball trough launch positions to physical playfield features (ie. wireforms) via vertical launch tubes. The playfield module can make use of any or all of the launch positions. The ones it uses are defined in the playfield module's <a class="el" href="_creating_playfield_module.html#PlayfieldModuleDefinitionFile">Module Definition File</a>.</p>
<p>When a P3 app executes, the software subsystem automatically reads the installed playfield module's <a class="el" href="_creating_playfield_module.html#PlayfieldModuleID">Playfield Module Identifier</a>, loads the associated <a class="el" href="_creating_playfield_module.html#PlayfieldModuleDefinitionFile">Module Definition File</a>, and provisions <a class="el" href="class_multimorphic_1_1_p3_1_1_mechs_1_1_trough_launcher.html">Multimorphic.P3.Mechs.TroughLauncher</a> objects based on the <a class="el" href="_creating_playfield_module.html#ModuleDefinitionTroughLaunchers">TroughLaunchers section</a>. Once the <a class="el" href="class_multimorphic_1_1_p3_1_1_mechs_1_1_trough_launcher.html">Multimorphic.P3.Mechs.TroughLauncher</a> objects are provisioned, the app can request access to one or more of them. If access is successfully granted, the app can then request launches from them whenever it wants.</p>
<p>Multimorphic.P3App.BallLauncher implements control of the <a class="el" href="class_multimorphic_1_1_p3_1_1_mechs_1_1_trough_launcher.html">Multimorphic.P3.Mechs.TroughLauncher</a> objects. The game app therefore makes calls to Multimorphic.P3App.BallLauncher to request access to the launcher objects and then to request actual launches. The sequence of events is:</p>
<ol type="1">
<li>Initialize Multimorphic.P3App.BallLauncher</li>
<li>Request access to TroughLaunchers</li>
<li>Request launches when applicable</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="InitializeBallLauncher"></a>
Initializing The Multimorphic.P3App.BallLauncher</h2>
<p>This gives the static BallLauncher class a reference to the P3Controller object. This should be run only once, when the app starts.</p>
<div class="fragment"><div class="line">BallLauncher.AssignP3(p3);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="RequestTroughLaunchers"></a>
Request Access To TroughLaunchers</h2>
<p>Doing this creates a link between the requested TroughLauncher and a string the app provides as a reference name. For each requested TroughLauncher, the subsystem makes sure the TroughLauncher is available and functional (tube is installed).</p>
<p>There are multiple ways to request access to TroughLaunchers.</p>
<ul>
<li>Request TroughLauncher by number</li>
</ul>
<p>Some apps know exactly which TroughLauncher they want to use. They can request access to the TroughLauncher as follows:</p>
<p>Example: </p><div class="fragment"><div class="line">// Assign TroughLauncher 3 to the key &quot;VUK_Left&quot;</div>
<div class="line">BallLauncher.AssignTroughLauncher(3, &quot;VUK_Left&quot;);</div>
</div><!-- fragment --><ul>
<li>Request TroughLauncher by TroughLauncher reference</li>
</ul>
<p>Some app developers query the <a class="el" href="class_multimorphic_1_1_p3_1_1_mechs_1_1_underkeeper.html" title="Under-playfield ball managements (for launching balls)">Multimorphic.P3.Mechs.Underkeeper</a> for a list of available TroughLaunchers and then request access to a TroughLauncher by providing the TroughLauncher reference.</p>
<p>Example: </p><div class="fragment"><div class="line">//Assign a launcher, provided by the Underkeeper, to the key &quot;VUK&quot;</div>
<div class="line">using System.Linq;</div>
<div class="line">Dictionary&lt;int, TroughLauncher&gt; launchers = p3.underkeeper.GetTroughLaunchers();</div>
<div class="line">TroughLauncher launcher = launchers.Values.First();</div>
<div class="line">BallLauncher.AssignTroughLauncher(launcher, &quot;VUK&quot;);</div>
</div><!-- fragment --><ul>
<li>Request TroughLauncher by Destination</li>
</ul>
<p>Some apps don't know anything about the TroughLaunchers and don't want to query the Underkeeper, but they know where they want the ball to go. To do this they can request access to TroughLaunchers by the desired Multimorphic.P3.Mechs.LaunchDestination.</p>
<p>Example: </p><div class="fragment"><div class="line">// Assign all of the TroughLaunchers that deliver to the LeftInlane to the key &quot;VUK_Left&quot;</div>
<div class="line">BallLauncher.AssignTroughLauncher(BallLauncher.GetTroughLaunchersForDestination(LaunchDestination.LeftInlane), &quot;VUK_Left&quot;);</div>
</div><!-- fragment --><p>Multiple TroughLaunchers can be assigned to the same key. In that case, the first one assigned to the key is the primary launcher, and the rest are backups. Launch requests made to that key will result in the P3 trying to launch from the primary launcher. If that fails, it will then attempt to launch for the next backup, if available.</p>
<h2 class="doxsection"><a class="anchor" id="RequestLaunchers"></a>
Request Launches</h2>
<p>Once at least one TroughLauncher is assigned to a key, a launch request can be made to that key. There are a few different ways to request launches.</p>
<p>Example </p><div class="fragment"><div class="line">BallLauncher.Launch(string Key, float StrengthPercentage);</div>
<div class="line">BallLauncher.Launch(string Key, float StrengthPercentage, double Delay);</div>
<div class="line">BallLauncher.Launch(string Key, float StrengthPercentage, double Delay, Multimorphic.P3.VoidDelegateNoArgs callback);</div>
</div><!-- fragment --><p>The StrengthPercentage parameter can be used to attempt to launch balls with different speeds. 0f is min speed. 0.5f is a medium speed. 1f is max speed. The Delay parameter forces a minimum time delay before a subsequent launch request will be serviced. The Callback parameter tells the BallLauncher logic to call the callback after the request is serviced.</p>
<p>The BallLauncher logic can accept any number of Launch requests. It puts them into a local queue and services them in order. Because it takes some time to Launch a ball and verify the launch succeeded (or failed), there will always be a delay between launches. There are two ways to schedule delays between launches (using the Delay parameter or inserting Dummy Launches), but even if no delays are scheduled, the BallLauncher logic will insert a one second delay. <br  />
</p>
<h3 class="doxsection"><a class="anchor" id="DummyLaunches"></a>
Dummy Launches</h3>
<p>Sometimes an app wants to schedule a launch into the future. It can do that with local delay logic, or it can precede the launch call with a Dummy launch. A Dummy Launch should always be followed with a real launch request, and it will make sure the real launch request isn't issued until the delay value passed in with the Dummy Launch. <br  />
</p>
<p>The following example will launch from the TroughLauncher assigned to "VUK_Left" after a 2.0 second delay. </p><div class="fragment"><div class="line">BallLauncher.DummyLaunch(2.0);</div>
<div class="line">BallLauncher.Launch(&quot;VUK_Left&quot;);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="TroughLauncherBallEntry"></a>
Detecting Balls Shot Into a TroughLauncher</h2>
<p>TroughLaunchers defined as Bidirectional can detect when a ball is shot into it from the playfield. When such a ball is detected, the TroughLauncher will post an "Evt_TroughLauncherEntry" ModeToMode event with the number of the TroughLauncher as the data object.</p>
<p>Note - As also described below in <a class="el" href="#DetectingShotsViaTroughLaunchers">Shots into TroughLaunchers</a>, module drivers that handle TroughLauncherEntry events are required to keep the event from propagating to apps. So app developers who want their apps to work with all playfields should also make use of playfield BallPaths, as described in the <a class="el" href="#DetectingShotsViaBallPaths">Ball Paths</a> section.</p>
<h1 class="doxsection"><a class="anchor" id="Flippers"></a>
Controlling Flippers</h1>
<p>FlippersMode is a P3App class that assists in controlling the flippers. Most apps will want to instantiate a FlippersMode object and add it to the mode queue in their BaseGameMode subclass. For example: </p><div class="fragment"><div class="line">// Declare the property</div>
<div class="line">private FlippersMode flippersMode;</div>
<div class="line"> </div>
<div class="line">// In the constructor, instantiate the object.</div>
<div class="line">flippersMode = new FlippersMode(p3, Priorities.PRIORITY_UTILITIES);</div>
<div class="line"> </div>
<div class="line">// In mode_started(), add the object to the Mode Queue </div>
<div class="line">p3.AddMode(flippersMode); </div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="EnablingFlippers"></a>
Enabling the Flippers</h2>
<p>When the flippers are enabled, they automatically pulse whenever their corresponding buttons are pressed. If the FlippersMode object has been added to the mode queue, posting the following events at any time will enable or disable the flippers: </p><div class="fragment"><div class="line">// Enable flippers</div>
<div class="line">PostModeEventToModes(EventNames.EnableFlippers, true);</div>
<div class="line"> </div>
<div class="line">// Enable flippers with no hold</div>
<div class="line">PostModeEventToModes(EventNames.EnableFlippersNoHold, true);</div>
<div class="line"> </div>
<div class="line">// Enable flippers with no hold by name</div>
<div class="line">string flipperName = &quot;flipperMezzanine&quot;;</div>
<div class="line">PostModeEventToModes(EventNames.EnableFlipperNoHoldByName, flipperName);</div>
<div class="line"> </div>
<div class="line">// Disable flippers</div>
<div class="line">PostModeEventToModes(EventNames.EnableFlippers, false);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="HidingFlippers"></a>
Hiding Flippers</h2>
<p>This feature relates to "hiding" a flipper from player access until re-added.</p>
<p>Send the event "Evt_RemoveFlipperByName" to remove the flipper from the available flippers. The flipper will be disabled immediately and also removed from subsequent enables to 'all flippers' until restored.</p>
<p>Send the event "Evt_ReAddRemovedFlipperByName" to restore a previously removed flipper from the available flippers. The flipper will be immediately enabled and also automatically enabled/disabled by subsequent commands to "all flippers".</p>
<div class="fragment"><div class="line">// Hide the flipper</div>
<div class="line">string flipperName = &quot;flipperMezzanine&quot;;</div>
<div class="line">PostModeEventToModes(EventNames.RemoveFlipperByName, flipperName);</div>
<div class="line"> </div>
<div class="line">// Restore the flipper</div>
<div class="line">PostModeEventToModes(EventNames.ReAddRemovedFlipperByName, flipperName);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="SettingDefaultFlipperStrength"></a>
Setting Default Flipper Strength</h2>
<p>There are two default <a class="el" href="class_multimorphic_1_1_p3_app_1_1_data_1_1_game_attribute.html">GameAttributes </a> that define the default flipper strength. These are changed by machine owners in the service mode, and they are accessed in code by: </p><div class="fragment"><div class="line">data.GetGameAttributeValue(&quot;LeftFlipperPulseTime&quot;).ToInt();</div>
<div class="line">data.GetGameAttributeValue(&quot;RightFlipperPulseTime&quot;).ToInt();</div>
</div><!-- fragment --><p> Whenever the flippers are enabled, the flipper strength is set to either these default values or to custom values, if set (see below).</p>
<h2 class="doxsection"><a class="anchor" id="ChangingFlipperStrength"></a>
Changing Flipper Strength During A Game</h2>
<p>To change the flipper strength during a game, post an event with a new FlipperStrengthStruct, defining the flipper to change and the new PulseTime, and then re-enable the flippers. </p><div class="fragment"><div class="line">// Set the left flipper pulse time to 20 milliseconds.</div>
<div class="line">PostModeEventToModes(EventNames.SetFlipperStrength, new FlipperStrengthStruct(&quot;flipperLwL&quot;, 20));</div>
<div class="line">PostModeEventToModes(EventNames.EnableFlippers, true);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="ResetFlipperStrength"></a>
Resetting Flipper Strength During A Game</h2>
<p>To reset a flipper to its default strength, post a reset event with the flipper name and then re-enable the flippers. </p><div class="fragment"><div class="line">PostModeEventToModes(EventNames.ResetFlipperStrength, &quot;flipperLwL&quot;);</div>
<div class="line">PostModeEventToModes(EventNames.EnableFlippers, true);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="PauseFlippers"></a>
Pausing The Flippers</h2>
<p>Pausing the flippers means to temporarily disable them. This is useful when a mode knows it wants the flippers disabled, but it wants the flippers to resume operation when it finishes, but only if the flippers were previously enabled. For example, a GUI menu mode pauses the flippers when it starts and unpauses them when it finishes. This allows the flippers to resume their previous state after the menu mode stops running. </p><div class="fragment"><div class="line">// To pause:</div>
<div class="line">PostModeEventToModes(EventNames.PauseFlippers, &quot;true&quot;);</div>
<div class="line"> </div>
<div class="line">// To unpause:</div>
<div class="line">PostModeEventToModes(EventNames.PauseFlippers, &quot;false&quot;);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="PulsingFlippers"></a>
Manually Driving a Flipper</h2>
<p>If you ever want to manually drive a flipper, use the following </p><div class="fragment"><div class="line">// Drive the left flipper (flip it and hold it up) </div>
<div class="line">PostModeEventToModes(EventNames.DriveFlipper, false);</div>
<div class="line"> </div>
<div class="line">// Drive the right flipper (flip it and hold it up) </div>
<div class="line">PostModeEventToModes(EventNames.DriveFlipper, true);</div>
<div class="line"> </div>
<div class="line">// Release the left flipper</div>
<div class="line">PostModeEventToModes(EventNames.ReleaseFlipper, false);</div>
<div class="line"> </div>
<div class="line">// Release the right flipper</div>
<div class="line">PostModeEventToModes(EventNames.ReleaseFlipper, true);</div>
<div class="line"> </div>
<div class="line">// Pulse the left flipper</div>
<div class="line">PostModeEventToModes(EventNames.PulseFlipper, false);</div>
<div class="line"> </div>
<div class="line">// Pulse the right flipper</div>
<div class="line">PostModeEventToModes(EventNames.PulseFlipper, true);</div>
<div class="line"> </div>
<div class="line">// Drive a flipper by name (flip it and hold it up) </div>
<div class="line">string name = &quot;flipperLwL&quot;;</div>
<div class="line">// If the name is not in the P3&#39;s list of Flippers, the call won&#39;t work.  So you might want to verify it.</div>
<div class="line">if (p3.Flippers().Contains(name))</div>
<div class="line">    PostModeEventToModes(EventNames.DriveFlipperByName, name);</div>
<div class="line"> </div>
<div class="line">// Release a flipper by name </div>
<div class="line">string name = &quot;flipperLwL&quot;;</div>
<div class="line">// If the name is not in the P3&#39;s list of Flippers, the call won&#39;t work.  So you might want to verify it.</div>
<div class="line">if (p3.Flippers().Contains(name))</div>
<div class="line">    PostModeEventToModes(EventNames.ReleaseFlipperByName, name);</div>
<div class="line"> </div>
<div class="line">// Pulse a flipper by name</div>
<div class="line">string name = &quot;flipperLwL&quot;;</div>
<div class="line">if (p3.Flippers().Contains(name))</div>
<div class="line">    PostModeEventToModes(EventNames.PulseFlipperByName, name);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="ControllingBumpers"></a>
Controlling Bumpers</h1>
<h2 class="doxsection"><a class="anchor" id="DrivingBumpers"></a>
Manually Driving Bumpers</h2>
<p>Bumpers include all devices that need to pulse a coil immediately due to a switch activation. All bumpers are defined in the <a class="el" href="_creating_playfield_module.html#PlayfieldModuleDefinitionFile">Module Definition File</a>. Similar to FlipperMode controlling flippers, BumperMode controls bumpers. </p><div class="fragment"><div class="line">// Declare the property</div>
<div class="line">private BumpersMode bumpersMode;</div>
<div class="line"> </div>
<div class="line">// In the constructor, instantiate the object.</div>
<div class="line">bumpersMode = new BumpersMode(p3, Priorities.PRIORITY_UTILITIES);</div>
<div class="line"> </div>
<div class="line">// In mode_started(), add the object to the Mode Queue </div>
<div class="line">p3.AddMode(bumpersMode); </div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="EnablingBumpers"></a>
Enabling the Bumpers</h2>
<p>By enabling bumpers, they'll automatically pulse in response to their switches being activated. If the BumpersMode object has been added to the mode queue, posting the following event at any time will enable or disable the bumpers: </p><div class="fragment"><div class="line">// Enable bumpers</div>
<div class="line">PostModeEventToModes(EventNames.EnableBumpers, true);</div>
<div class="line"> </div>
<div class="line">// Disable bumpers</div>
<div class="line">PostModeEventToModes(EventNames.EnableBumpers, false);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="PulsingBumpers"></a>
Pulsing a Bumper</h2>
<p>If you ever want to manually pulse a bumper, use the following </p><div class="fragment"><div class="line">// Pulse the left slingshot </div>
<div class="line">PostModeEventToModes(EventNames.PulseSlingshot, false);</div>
<div class="line"> </div>
<div class="line">// Pulse the right slingshot </div>
<div class="line">PostModeEventToModes(EventNames.PulseSlingshot, true);</div>
<div class="line"> </div>
<div class="line">// Pulse any bumper by name (including the left and right slingshots) </div>
<div class="line">string name = &quot;slingR&quot;;</div>
<div class="line">// If the name is not in the P3&#39;s list of Bumpers, the pulse call won&#39;t work.  So you might want to verify it.</div>
<div class="line">if (p3.GetBumpers().Contains(name) </div>
<div class="line">    PostModeEventToModes(EventNames.PulseBumperByName, name);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="WallScoopAssembly"></a>
Wall/Scoop Assembly</h1>
<p>The P3's wall/scoop assembly has 6 wall elements and 6 scoop elements. Each element is individually controllable and defaults to down, such that its top is flush with the P3's playing surface. When up, the element extends a couple of inches above the playing surface. The 6 wall elements are adjacent to each other and span the width of the playfield just beyond the far edge of the main playfield LCD. The 6 scoop elements are adjacent to each other and span the width of the playfield just behind the walls. A raised wall will block the path of a ball. When all 6 walls are raised, access to the upper playfield is entirely blocked in a way that will keep the balls on the lower playfield. A raised scoop creates a hole in the playing surface and acts as a backboard to direct the ball into an internal collection pan that feeds back into the P3's ball trough. When all 6 scoops are up and all 6 walls are down, balls traveling up the playfield go into the scoop collection pan, thereby taking them out of play.</p>
<p>Note - there are currently 2 versions of the Wall/Scoop assemblies. Original P3 Wall/Scoop assemblies have coils lifting the devices and a single long-beam opto (well 2, but they're interpreted as 1) detecting ball entries. In 2023, the assemblies switched to servo-driven assemblies, and each scoop gained its own entrance switch (the longbeams were removed). Apps that use the mechs interface to them the same way. Any specific detail is handled by lower level code in the framework. That said, whereas coils can lower all devices at the same time, servo-controlled devices need to be lowered sequentially. So if a request is made to lower them all, the framework will convert that to a sequence of individual requests that happen sequentially, with approximately 0.2s between requests. Also, it takes a little bit longer for a servo-driven device to rise relative to a coil-driven device. So if you're hoping to raise a device quickly to block a shot exit, or something, you might need to consider when you make the request to ensure the device has enough time to rise enough to block the incoming ball.</p>
<h2 class="doxsection"><a class="anchor" id="Walls"></a>
Walls</h2>
<h3 class="doxsection"><a class="anchor" id="RaisingAndLoweringWalls"></a>
Raising and Lowering Walls</h3>
<div class="fragment"><div class="line">// Raise a wall</div>
<div class="line">p3.wallScoopMode.RaiseWall(index); // index can be 0-5, where 0 is the leftmost wall and 5 is the rightmost wall</div>
<div class="line">// Raise all walls with a left-to-right sequence </div>
<div class="line">p3.wallScoopMode.RaiseWalls(Multimorphic.P3.Mechs.WallScoopSequence.FromLeft);</div>
<div class="line">// Other available sequences are Simultaneously (same as FromLeft), FromLeft, FromRight, FromCenter, FromEdges</div>
<div class="line"> </div>
<div class="line">// Lower a wall</div>
<div class="line">p3.wallScoopMode.LowerWall(index); // index can be 0-5, where 0 is the leftmost wall and 5 is the rightmost wall</div>
<div class="line">// Lower all walls</div>
<div class="line">p3.wallScoopMode.LowerWalls(Multimorphic.P3.Mechs.WallScoopSequence.Simultaneously);</div>
</div><!-- fragment --> <h3 class="doxsection"><a class="anchor" id="DetectingBallsHittingWalls"></a>
Detecting Ball Hits</h3>
<p>The ball tracking functionality of the P3 can be used to detect when a ball hits a wall. The default P3Playfield prefab includes "gates" in front of each wall. When a ball hits the gate, P3Playfield posts the GUI-to-Mode event "Evt_Wall" with a string parameter representing the number of the wall hit. To receive that event in a mode, register an event handler as follows: </p><div class="fragment"><div class="line">AddGUIEventHandler(&quot;Evt_Wall&quot;, WallEventHandler);</div>
</div><!-- fragment --><p> Then define a handler like the following: </p><div class="fragment"><div class="line">private void WallEventHandler(string eventName, object eventData) {</div>
<div class="line">    int wallIndex = Convert.ToInt32((string)eventData);</div>
<div class="line">    // Add code to react to the wall being hit</div>
<div class="line">}</div>
</div><!-- fragment --> <h2 class="doxsection"><a class="anchor" id="Scoops"></a>
Scoops</h2>
<h3 class="doxsection"><a class="anchor" id="RaisingAndLoweringScoops"></a>
Raising and Lowering Scoops</h3>
<div class="fragment"><div class="line">// Raise a scoop</div>
<div class="line">p3.wallScoopMode.RaiseScoop(index); // index can be 0-5, where 0 is the leftmost scoop and 5 is the rightmost scoop</div>
<div class="line">// Raise all scoops with a left-to-right sequence </div>
<div class="line">p3.wallScoopMode.RaiseScoops(Multimorphic.P3.Mechs.WallScoopSequence.FromLeft);</div>
<div class="line">// Other available sequences are Simultaneously (same as FromLeft), FromLeft, FromRight, FromCenter, FromEdges</div>
<div class="line"> </div>
<div class="line">// Lower a scoop</div>
<div class="line">p3.wallScoopMode.LowerScoop(index); // index can be 0-5, where 0 is the leftmost scoop and 5 is the rightmost scoop</div>
<div class="line">// Lower all scoops</div>
<div class="line">p3.wallScoopMode.LowerScoops(Multimorphic.P3.Mechs.WallScoopSequence.Simultaneously);</div>
</div><!-- fragment --> <h3 class="doxsection"><a class="anchor" id="DetectingBallsInScoops"></a>
Detecting Balls Shot Into Scoops</h3>
<p>When a scoop receives a ball, the wall/scoop assembly posts the ModeToMode event "Evt_ScoopHit" with an int parameter representing the scoop that received the ball. The coil-based scoops in original P3s (as opposed to the motorized assemblies introduced in 2022) don't have individual switches to detect ball hits. Rather, those assemblies work automatically with the P3's ball tracking to identify the scoop that received the ball. To receive the event, subscribe to the "Evt_ScoopHit" event as follows: </p><div class="fragment"><div class="line">AddModeEventHandler(&quot;Evt_ScoopHit&quot;, ScoopHitEventHandler, Priority);</div>
</div><!-- fragment --><p> Then define a handler like the following: </p><div class="fragment"><div class="line">private bool ScoopHitEventHandler(string eventName, object eventData) {</div>
<div class="line">    int doorNum = (int)eventData;</div>
<div class="line">    processDoorEntry(doorNum);</div>
<div class="line">    return SWITCH_STOP;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note - because of possible grid inaccuracies and potential changes to the open walls/scoops before the ball's entrance into a scoop is detected, it is recommended to not assume the reported scoop is the exact one the ball entered. Rather, use it as a best guess and add code to figure out which open scoop was the closest to the reported scoop when the ball likely entered.</p>
<h1 class="doxsection"><a class="anchor" id="LEDs"></a>
LEDs</h1>
<p>Physical LED elements are generally used to provide visual status or decorative effects. The P3 software framework, typically when parsing the <a class="el" href="_creating_playfield_module.html#PlayfieldModuleDefinitionFile">Module Definition File</a>, maps all defined LEDs into the p3 MachineController object, which is accessible in all modes (see examples below). Changing the colors of the physical LEDs is done by running LEDScripts. The scripts can do simple things like set LED colors and complex things like choreograph a sequence of timed color changes. The scripts work in conjunction with an LEDController, which manages the scripts, steps them through the defined sequence of commands, and updates the actual LED elements when the scripts indicate to do so.</p>
<p>Each LEDScript defines the desired operation of only one LED. To change a bunch of LEDs at the same time or in a choreographed manner, define a bunch of LEDScripts, one for each LED in the desired choreography. Then tell the LEDController to run each script.</p>
<p>To deal with situations where one mode wants to control the LEDs in one way, and a higher priority mode wants to control them in another way, each LEDScript has a priority property. While the LEDController steps through the commands for all LEDScripts it knows about, it only updates the actual physical LED elements when the highest priority LEDScript actively running for each LED says to do so. When the highest priority LEDScript finishes (or is removed by a mode), the next highest priority LEDScript takes over. In this manner, it's possible to have any number of simultaneously running modes requesting changes to any or all of the LEDs, and the actual LEDs will always represent the colors requested by the highest priority LEDScripts.</p>
<h2 class="doxsection"><a class="anchor" id="LEDScripts"></a>
LEDScripts</h2>
<h3 class="doxsection"><a class="anchor" id="LEDScriptsBasic"></a>
Basic Operation</h3>
<p>To instantiate and run a script: </p><div class="fragment"><div class="line">// Instantiate a new LEDScript</div>
<div class="line">LEDScript wall0Script = new LEDScript(p3.LEDs[&quot;wall0&quot;], priority)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// Define the LED effects the script should make happen</div>
<div class="line"> </div>
<div class="line">// Not needed the first time, but you can clear a script at any time to set up a new pattern.</div>
<div class="line">// Be sure to stop the LEDController from running the script before clearing it.</div>
<div class="line">wall0Script.Clear();</div>
<div class="line"> </div>
<div class="line">// Turn the LED blue instantly, and leave it blue for 0.5s.  </div>
<div class="line">wall0Script.AddCommand(Multimorphic.P3.Colors.Color.blue, 0, 0.5);</div>
<div class="line"> </div>
<div class="line">// Turn the LED red for 0.5s.  During the first 0.1s of that 0.5s, it should fade from the previous color</div>
<div class="line">wall0Script.AddCommand(Multimorphic.P3.Colors.Color.red, 0.1, 0.5);</div>
<div class="line"> </div>
<div class="line">// Fade the LED to white over the course of 1s.</div>
<div class="line">wall0Script.AddCommand(Multimorphic.P3.Colors.Color.white, 1.0, 1.0);</div>
<div class="line"> </div>
<div class="line">// Do not auto-remove the script when it finishes running the commands</div>
<div class="line">// (e.g. leave the LED the color of the last command)</div>
<div class="line">wall0Script.autoRemove = false;</div>
<div class="line"> </div>
<div class="line">// Setting the name isn&#39;t required, but it can sometimes be useful when managing multiple scripts. </div>
<div class="line">wall0Script.scriptName = &quot;wall0Script_sequenceA&quot;;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// Add the script to the LEDController to start it.</div>
<div class="line">// RunTime == -1 will repeat the script until it is removed.  Delay == 0 means start running it immediately</div>
<div class="line">// RunTime of 0 will run the script fully once.</div>
<div class="line">// RunTime &gt; 0 will only run the script until it finishes or until the time expires, whichever is shorter.</div>
<div class="line">p3.LEDController.AddScript(wall0Script, -1, 0);</div>
</div><!-- fragment --><p>To remove a script (e.g. stop it from running) </p><div class="fragment"><div class="line">p3.LEDController.RemoveScript(wall0Script)</div>
</div><!-- fragment --><p>To run a set of scripts for as long as a mode is active, add the scripts to the LEDController in &lt;YourMode&gt;.mode_started() and remove them from the LEDController in &lt;YourMode&gt;.mode_stopped().</p>
<h3 class="doxsection"><a class="anchor" id="LEDScriptsChase"></a>
Example: Chase</h3>
<p>Here's a sample mode that will run a chase pattern on a sequence of LEDs once. The chase will last 1s, and only 1 element will be on at any given time.</p>
<div class="fragment"><div class="line">public class ChaseLEDShowMode : P3Mode</div>
<div class="line">{</div>
<div class="line">    protected List&lt;LEDScript&gt; ledScripts;</div>
<div class="line">  </div>
<div class="line">    double sweepDuration;</div>
<div class="line">    double onTime;</div>
<div class="line">    double onFadeTime;</div>
<div class="line"> </div>
<div class="line">    public ChaseLEDShowMode(P3Controller controller, int priority, List&lt;LED&gt; sweepLEDs)</div>
<div class="line">      : base(controller, priority)</div>
<div class="line">    {</div>
<div class="line">        sweepDuration = 1.0;</div>
<div class="line">        onTime = sweepDuration / sweepLEDs.Count;</div>
<div class="line">        onFadeTime = onTime / 2.0;</div>
<div class="line">        ledScripts = new List&lt;LEDScript&gt;();</div>
<div class="line"> </div>
<div class="line">        for (int i=0; i&lt;sweepLEDs.Count; i++) {</div>
<div class="line">            LEDScript script = new LEDScript(sweepLEDs[i], priority);</div>
<div class="line">            ledScripts.Add(script);</div>
<div class="line">            script.AddCommand(Multimorphic.P3.Colors.Color.white, onFadeTime, onTime);</div>
<div class="line">            script.autoRemove = true;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    public override void mode_started()</div>
<div class="line">    {</div>
<div class="line">        double delay;</div>
<div class="line">        for (int i=0; i&lt;ledScripts.Count; i++) {</div>
<div class="line">            delay = (sweepDuration/ledScripts.Count)*i;</div>
<div class="line">            p3.LEDController.AddScript(ledScripts[i], sweepDuration, delay);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    public override void mode_stopped()</div>
<div class="line">    {</div>
<div class="line">        for (int i=0; i&lt;ledScripts.Count; i++) {</div>
<div class="line">            p3.LEDController.RemoveScript(ledScripts[i]);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The scripts are all set up with the exact same command. The chase works because the scripts are added to the LEDController with incremental delays. Another way to implement a chase is to fully define the colors that each LED should be throughout the duration of the chase pattern. The advantage in doing it the way the example does it is that the LEDs will be whatever color a lower priority script wants them to be until the chase color is set for "onTime". After "onTime" elapses on each respective LED, the LEDs will return to the color of the lower priority script. Sometimes this is desirable. Othertimes you might want full control of the LED colors until the chase pattern completely finishes. <br  />
</p>
<h3 class="doxsection"><a class="anchor" id="LEDScriptsHelper"></a>
LEDScript Helper Methods</h3>
<p>P3App contains the static class <a class="el" href="class_multimorphic_1_1_p3_app_1_1_modes_1_1_l_e_d_helpers.html">LEDHelpers</a> to help implement common lighting patterns on individual scripts. These helpers first remove the script from the LEDController (in case it was already running), then set up the commands, and then add the script back to the LEDController, thereby running it.</p>
<div class="fragment"><div class="line">LEDScript wall0Script = new LEDScript(p3.LEDs[&quot;wall0&quot;], priority)</div>
<div class="line"> </div>
<div class="line">// Drive an LED to a specific color (and leave it there)</div>
<div class="line">wall0Script = LEDHelpers.OnLED(p3, wall0Script, Multimorphic.P3.Colors.Color.red);</div>
<div class="line"> </div>
<div class="line">// Drive an LED to a specific color (blue) before changing it to a final color (red)</div>
<div class="line">wall0Script = LEDHelpers.PulseLED(p3, wall0Script, Multimorphic.P3.Colors.Color.blue, Multimorphic.P3.Colors.Color.red); </div>
<div class="line"> </div>
<div class="line">// Blink the wall0 LED white (and off)</div>
<div class="line">wall0Script = LEDHelpers.BlinkLED(p3, wall0Script, Multimorphic.P3.Colors.Color.white); </div>
</div><!-- fragment --><p>Note - the helper methods have many variations, allowing you to set various parameters to adjust timing.</p>
<h3 class="doxsection"><a class="anchor" id="SynchronizingLEDScripts"></a>
Synchronizing LEDScripts</h3>
<p>LEDScript synchronizers can be used to ensure scripts start in synch with other scripts. Synchronizers are defined by the following 3 parameters:</p>
<ul>
<li>Index - An integer used to reference the synchronizer.</li>
<li>Interval - The time (in seconds) between "firings" of the synchronizer. Each time the synchronizer fires, all new scripts using that synchronizer will start.</li>
<li>Dependent Synchronizer - The index of another synchronizer that needs to fire before this synchronizer starts. This can be used to ensure, for example, that a 2-second synchronizer starts at the same time that a 1-second synchronizer fires, keeping them in sync even though the new one runs half as fast.</li>
</ul>
<p>To add a new synchronizer from a mode: </p><div class="fragment"><div class="line">// If creating a fully independent synchronizer</div>
<div class="line">p3.LEDController.AddSynchronizer(0, 1.0);</div>
<div class="line"> </div>
<div class="line">// If creating another synchronizer that&#39;s dependent on a previous synchronizer:</div>
<div class="line">p3.LEDController.AddSynchronizer(1, 2.0, 0);</div>
</div><!-- fragment --><p>To ensure an LEDScript starts when a synchronizer fires, assign the desired synchronizer to the script's synchronizerIndex property:</p>
<div class="fragment"><div class="line">ledScript.synchronizerIndex = 0;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="LEDSimulations"></a>
Simulating LEDs</h2>
<p>The framework is able to simulate physical LEDs by showing virtual LED components on display 8. To enable this functionality in your simulations, add the following to your app:</p>
<p>1) Copy P3SampleApp/Assets/Resources/Prefabs/GUI/LEDSimulator.prefab* (prefab and meta file) to your project</p>
<p>2) Drag the prefab from the Project panel in Unity into your Attract scene.</p>
<p>3) Save the scene.</p>
<p>That <b>might</b> be all you need to do. Simulate the game and switch the display to display 8 to see if the LEDs are showing up in Attract mode (P3 LEDs like walls/scoops and side targets should appear. Playfield-module lights depends on the playfield module your app is configured to use). If you're using a playfield module whose module driver already has the below code, it'll work. Otherwise, you'll need to add the code from steps 2-4 below to your app.</p>
<p>4) Add a class (such as RGBLEDs) to your project with the following <b>static</b> methods:</p>
<p>Note - as said in the paragraph above, you'll only need the following code in your app if the module driver you're simulating against doesn't already have it.</p>
<div class="fragment"><div class="line">public static void SetupLEDEventHandlers(P3Controller p3)</div>
<div class="line">{</div>
<div class="line">    NetProcMachine.EventManager.Post(P3App.Modes.EventNames.InstallModeLEDCommandHandlers, true);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">public static void SendLEDsToSimulator(P3Controller p3)</div>
<div class="line">{</div>
<div class="line">    if (p3.simulated)</div>
<div class="line">    {</div>
<div class="line">        foreach (LED led in p3.LEDs.Values)</div>
<div class="line">        {</div>
<div class="line">            SendLEDToSimulator(p3, led);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private static void SendLEDToSimulator(P3Controller p3, LED led)</div>
<div class="line">{</div>
<div class="line">    if (led.Location == null)</div>
<div class="line">    {</div>
<div class="line">        Multimorphic.P3App.Logging.Logger.Log(P3App.Logging.LogCategories.ModuleDriver, &quot;Can&#39;t simulate LED:&quot; + led.Name + &quot; because it has no location&quot;);</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        p3.ModesToGUIEventManager.Post(&quot;Evt_AddLEDToSimulator&quot;, led);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>5) Add the following code to your BaseGameMode.mode_started():</p>
<div class="fragment"><div class="line">RGBLEDs.SetupLEDEventHandlers(p3);</div>
</div><!-- fragment --><p>6) Add the following code to your AttractMode.SceneLiveEventHandler(...) override </p><div class="fragment"><div class="line">RGBLEDs.SendLEDsToSimulator(p3);</div>
</div><!-- fragment --><p>Now when you simulate and change the simulator game window to display 8, you should see virtual representations of all LEDs in the game that have defined locations, and the colors should update just like the colors of the physical LEDs.</p>
<p>The LEDSimulator is marked DontDestroyOnLoad and will carry over to your other scenes after Attract mode.</p>
<h1 class="doxsection"><a class="anchor" id="DetectingShots"></a>
Detecting Playfield Shots</h1>
<h2 class="doxsection"><a class="anchor" id="DetectingShotsViaBallPaths"></a>
Ball Paths</h2>
<p>Game apps that want to work with upper playfield modules need to know when balls are shot into paths, targets, mechs, etc. The associated playfield module driver usually handles the low level code to detect these things and then informs the game app via events, as defined in <a class="el" href="_creating_playfield_module.html#BallPaths">BallPaths Section</a>.</p>
<p>Example code to subscribe to ballPath events: </p><div class="fragment"><div class="line">// Here&#39;s an example of how to subscribe to generically-defined BallPaths in the playfield module drivers.</div>
<div class="line">// You might use code like this if you want your game to work with all playfield modules or if you want</div>
<div class="line">// to use the module drivers detection logic for when playfield shots, targets, holes, etc are hit.</div>
<div class="line">foreach (BallPathDefinition shot in p3.BallPaths.Values)</div>
<div class="line">{</div>
<div class="line">    if (shot.ExitType == BallPathExitType.Target)</div>
<div class="line">    {</div>
<div class="line">        if (shot.CompletedEvent.Contains(&quot;_inactive&quot;))</div>
<div class="line">        {</div>
<div class="line">            // Completed event looks like sw_&lt;swithName&gt;_inactive, use a switch handler.</div>
<div class="line">            string[] strippedSwitchName = shot.CompletedEvent.Split(&#39;_&#39;);</div>
<div class="line">            string swName = strippedSwitchName[1];</div>
<div class="line">            add_switch_handler(swName, &quot;active&quot;, 0, TargetHitEventHandler);</div>
<div class="line">        }</div>
<div class="line">        else</div>
<div class="line">        {</div>
<div class="line">            // Otherwise use a Mode2Mode event handler.</div>
<div class="line">            AddModeEventHandler(shot.CompletedEvent, TargetPathHitEventHandler, priority);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    else if (shot.ExitType == BallPathExitType.Hole)</div>
<div class="line">    {</div>
<div class="line">        AddModeEventHandler(shot.CompletedEvent, HoleHitEventHandler, priority);</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        AddModeEventHandler(shot.CompletedEvent, ShotHitEventHandler, priority);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>With example event handlers: </p><div class="fragment"><div class="line">private bool TargetHitEventHandler(Switch sw)</div>
<div class="line">{</div>
<div class="line">    // Add target hit logic here</div>
<div class="line">    return SWITCH_CONTINUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private bool TargetPathHitEventHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Add target hit logic here</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private bool HoleHitEventHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Add hole hit logic here</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private bool ShotHitEventHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Add shot hit logic here</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="DetectingShotsViaTroughLaunchers"></a>
Shots into TroughLaunchers</h2>
<p>Some playfield modules have shots that go into TroughLaunchers. In most cases, the Evt_TroughLauncherEntry event is intercepted by the playfield module driver code and exposed via a BallPath. In those cases, the module driver is required to issue an EVENT_STOP on the Evt_TroughLauncherEntry event so that it does not then propagate to game code.</p>
<p>There are some playfields that don't have module drivers because they don't have any features other than TroughLaunchers. The Cannon Lagoon playfield is one such playfield module. To detect balls shot into TroughLaunchers on playfields without module drivers, it's necessary to subscribe to the "Evt_TroughLauncherEntry" event. Because other playfields stop the event, playfield-agnostic apps can safely subscribe to "Evt_TroughLauncherEntry" events AND process BallPaths.</p>
<p>Example code for subscribing to TroughLauncherEntries </p><div class="fragment"><div class="line">AddModeEventHandler(&quot;Evt_TroughLauncherEntry&quot;, TroughLauncherEntryEventHandler, Priority);</div>
</div><!-- fragment --><p>Code for processing the entry </p><div class="fragment"><div class="line">private bool TroughLauncherEntryEventHandler(string eventName, object eventData)</div>
<div class="line">{</div>
<div class="line">    int troughLauncherIndex = (int)eventData;</div>
<div class="line">    Multimorphic.P3App.Logging.Logger.Log(LogCategories.Game, &quot;TroughLauncherEntry event received for trough launcher index: &quot; + troughLauncherIndex.ToString());</div>
<div class="line"> </div>
<div class="line">    // Add logic here to process the TroughLauncherEntry (ie. score, launch a new ball, run a lightshow, etc)</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="DetectingShotsIntoMechs"></a>
Shots into Mechs</h2>
<p>Playfield modules that have mechs than can hold balls are required to either default them into pass-through (if possible) or define device capabilities so apps can communicate with the mechs, even without direct knowledge of which playfield is installed.</p>
<p>The Lexy Lightspeed 8-ball spaceship lock mech is an example of a mech that does not default to pass-through. Rather, it defines device capabilities, and the capabilities structure includes event names for configuring the spaceship to eject (release) or lock (hold onto) balls that are shot into it.</p>
<p>A PlayfieldDeviceCapabilitiesStruct defines the capabilities of a single mech. </p><div class="fragment"><div class="line">public struct PlayfieldDeviceCapabilitiesStruct</div>
<div class="line">{</div>
<div class="line">    public string name;</div>
<div class="line">    public bool canLock;</div>
<div class="line">    public int numBallsCanLock;</div>
<div class="line">    public bool canDrain;</div>
<div class="line">    public bool canEject;</div>
<div class="line"> </div>
<div class="line">    // Names of events sent by the app to control the mech</div>
<div class="line">    public string toEventNameCalibrate;</div>
<div class="line">    public string toEventNameUnload;</div>
<div class="line">    public string toEventNameUnloadIfNotEmpty;</div>
<div class="line">    public string toEventNameEject;</div>
<div class="line">    public string toEventNameDrain;</div>
<div class="line">    public string toEventNameMove;</div>
<div class="line">    public string toEventNameLock;</div>
<div class="line">    public string toEventNameGetNumBallsLocked;</div>
<div class="line"> </div>
<div class="line">    // Names of events sent by the module driver to notify the app</div>
<div class="line">    public string fromEventNameBallEntered;</div>
<div class="line">    public string fromEventNameBallDrained;</div>
<div class="line">    public string fromEventNameBallEjected;</div>
<div class="line">    public string fromEventNameBallLocked;</div>
<div class="line">    public string fromEventNameNumBalls;</div>
<div class="line">    public string fromEventNameUnloadFinished;</div>
<div class="line">    public string fromEventNameCalibrateFinished;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To use the playfield capabilities, first, set up a handler to receive capabilities upon request: </p><div class="fragment"><div class="line">AddModeEventHandler(EventNames.PlayfieldDeviceCapabilities, PlayfieldDeviceCapabilitiesEventHandler, Priority);</div>
</div><!-- fragment --><p>Then post the PlayfieldGetDeviceCapabilities event to request capabilities: </p><div class="fragment"><div class="line">PostModeEventToModes(EventNames.PlayfieldGetDeviceCapabilities, true);</div>
</div><!-- fragment --><p>Process the returned capabilities in the event handler. Capabilities are returned as a List of <a class="el" href="struct_multimorphic_1_1_p3_app_1_1_modes_1_1_playfield_module_1_1_playfield_device_capabilities_struct.html">Multimorphic.P3App.Modes.PlayfieldModule.PlayfieldDeviceCapabilitiesStruct</a>: </p><div class="fragment"><div class="line">private List&lt;PlayfieldDeviceCapabilitiesStruct&gt; deviceCapabilities = new List&lt;PlayfieldDeviceCapabilitiesStruct&gt;();</div>
<div class="line">private bool PlayfieldDeviceCapabilitiesEventHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    deviceCapabilities = (List&lt;PlayfieldDeviceCapabilitiesStruct&gt;)evtData;</div>
<div class="line">    foreach (PlayfieldDeviceCapabilitiesStruct caps in deviceCapabilities)</div>
<div class="line">    {</div>
<div class="line">        AddModeEventHandler(caps.fromEventNameBallEntered, DeviceBallEnteredHandler, Priority);</div>
<div class="line">        if (caps.canEject)</div>
<div class="line">                AddModeEventHandler(caps.fromEventNameBallEjected, DeviceBallEjectedHandler, Priority);</div>
<div class="line">        else if (caps.canDrain)</div>
<div class="line">            AddModeEventHandler(caps.fromEventNameBallDrained, DeviceBallDrainedHandler, Priority);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private bool DeviceBallEnteredHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    var caps = deviceCapabilities.FirstOrDefault(dc =&gt; dc.fromEventNameBallEntered == evtName);</div>
<div class="line">    if (caps.canEject)</div>
<div class="line">    {</div>
<div class="line">        // Tell the module driver to eject the ball, event arg is number of balls to eject</div>
<div class="line">        PostModeEventToModes(caps.toEventNameEject, 1);</div>
<div class="line">    }</div>
<div class="line">    else if (caps.canDrain)</div>
<div class="line">    {</div>
<div class="line">        // Tell the module driver to drain the ball, event arg is number of balls to drain</div>
<div class="line">        PostModeEventToModes(caps.toEventNameDrain, 1);</div>
<div class="line">    }</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private bool DeviceBallEjectedHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Add logic here to process the ball ejected out of the device (ie. score, run a lightshow, etc)</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private bool DeviceBallDrainedHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Add logic here to process the ball drained out of the device (ie. score, launch a new ball, run a lightshow, etc)</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Beware a module driver can send both a Capabilities event and a BallPath event when a ball drains. For example, when the ball drains below the saucer in Lexy Lightspeed, the module driver sends the Capabilities event "Evt_SaucerBallDrained" and the Hole BallPath event "Evt_ShipExitBottom". In this case, the application can choose to handle only the BallPath event to avoid duplicate processing. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
