<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P3-SDK: The Mode Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">P3-SDK<span id="projectnumber">&#160;0.9</span>
   </div>
   <div id="projectbrief">P3 Software Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('_mode_layer.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The Mode Layer </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__docs_260_01_the_01_mode_01_layer"></a></p>
<h1 class="doxsection"><a class="anchor" id="ModeIntr"></a>
Introduction to Mode Programming</h1>
<p>As described in the <a class="el" href="_app_structure.html#Modes">Modes</a> section, the execution of a P3 app is controlled by a group of modes. When modes are created, they're given a priority, and they start running when they're added to the P3's mode queue. Here's an example of creating and starting a mode: </p><div class="fragment"><div class="line">ShotsMode shotsMode = new ShotsMode(p3, Priorities.PRIORITY_MECH);</div>
<div class="line">p3.AddMode(shotsMode);</div>
</div><!-- fragment --><p>In this example, ShotsMode is a class (definition not shown) that inherits from <a class="el" href="class_multimorphic_1_1_net_proc_machine_1_1_machine_1_1_mode.html">Multimorphic.NetProcMachine.Machine.Mode</a>. When a mode is created, the main p3 object and an integer representing its priority are passed into the constructor. In this case, a pre-defined constant Priorities.PRIORITY_MECH contains the priority number. Keeping all priorities defined in a central place makes it easier to manage priorities for all modes.</p>
<p>After being added to the mode queue via the p3.AddMode(shotsMode) call, shotsMode is effectively running. Running means that the mode is active and ready to receive events from the P3. Events can be switch events from the actual P3 machine, timer events, or events sent from other modes or GUI scripts. Refer to the <a class="el" href="#EventsInModeLayer">Events in Mode Layer</a> and <a class="el" href="_g_u_i_layer.html#EventsInGUILayer">Events in GUI Layer</a> sections for more information on events.</p>
<p>To stop a mode from running, simply remove it from the mode queue as follows: </p><div class="fragment"><div class="line">p3.RemoveMode(shotsMode)</div>
</div><!-- fragment --><p>Note - Common mistakes made with modes include creating them but never starting them and creating them with too low of a priority. Higher priority modes receive events before lower priority modes, and a mode can decide whether or not an event it receives should continue being serviced by lower priority modes.</p>
<h1 class="doxsection"><a class="anchor" id="ModeOverview"></a>
An Overview of P3 Modes</h1>
<p>All P3 apps have an app mode which starts the proceedings (usually by starting the attract mode and a game manager mode) and ends the proceedings (by shutting down the app).</p>
<p>In the interim, the game manager mode will start the primary game mode when appropriate. When the game manager receives an event indicating that the start button has been pressed, it checks the money mode (which is started by the game manager mode when it initializes) to ensure that enough credits are available, then it will start the base game mode (e.g. P3SABaseGameMode).</p>
<p>The base game mode starts the flipper mode and ball launch mode to enable game play. It will also start ball drain mode to catch the end of a ball. The game mode keeps track of the number of balls in play as well as the balls remaining in the game. A separate score mode keeps track of the score.</p>
<h1 class="doxsection"><a class="anchor" id="IncludedModes"></a>
Modes Included In The Framework</h1>
<p>The framework includes frequently required modes. Some examples of common modes are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Mode  </th><th class="markdownTableHeadLeft">Responsibility  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">BaseGameMode  </td><td class="markdownTableBodyLeft">- Derived from BaseAppMode, which instantiates modes used in all apps (e.g. VolumeMode, etc).<br  />
- The base mode used in all games.<br  />
- Instantiates modes that make up the entire game (e.g. AttractMode, GameManagerMode, GameAttributeManagerMode, etc)<br  />
- This is not the base class of all game modes. Base here means Primary, Central or Core mode.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">AttractMode  </td><td class="markdownTableBodyLeft">- Show ready-for-game state to the user<br  />
- Attract art, sound, and lightshow<br  />
- Receive notification of Start button press<br  />
- Start game mode  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GameManagerMode  </td><td class="markdownTableBodyLeft">- Starts money mode<br  />
- Awaits Start button presses<br  />
- Starts game mode<br  />
- Awaits game ending  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">GameAttributeManagerMode  </td><td class="markdownTableBodyLeft">- Keeps track of all DataManagerModes, which are modes used to track data (settings, statistics, high scores, etc.)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">MoneyMode  </td><td class="markdownTableBodyLeft">- Receives events from coin door mechs and attract mode to add/subtract credits<br  />
- Reports number of credits available  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">BallLauncherMode  </td><td class="markdownTableBodyLeft">- Launches a ball into play  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">BallSaveMode  </td><td class="markdownTableBodyLeft">- Watches for ball drains within a defined timeframe<br  />
- Prevents registration of a ball drain during saver time<br  />
- Triggers BallLauncherMode when a ball drains during saver time  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">BallSearchMode  </td><td class="markdownTableBodyLeft">- Watches for absence of switch activity (an indicator of a potential stuck ball situation).<br  />
- Activates all mechanisms until switch activity is received.  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="Sub-classing"></a>
Sub-classing From Existing Modes</h1>
<p>As a developer, you can extend and customize the provided Modes to best suit the specific behavior for your app. It is inevitable that you will sub-class (i.e., extend) the provided mode classes to leverage the methods and fields they define, and amend or augment functionality as needed. For example, every Mode that you will define could be sub-classed from P3Mode:</p>
<div class="fragment"><div class="line">public class DebugMode : P3Mode</div>
</div><!-- fragment --><p>However in many cases, it may be better to sub-class one of the P3Mode subclasses that have been provided (<a class="el" href="class_multimorphic_1_1_p3_app_1_1_modes_1_1_game_mode.html">GameMode</a>). For example, a common usage is to define your own subclass of GameMode (&lt;AppCode&gt;GameMode) and then subclass this class to be able to reuse helpful methods that you define along the way.</p>
<h1 class="doxsection"><a class="anchor" id="EventsInModeLayer"></a>
Events in Mode Layer</h1>
<p>Note - This section describes how to send and receive events in Modes. For sending and receiving events in GUI scripts, please refer to <a class="el" href="_g_u_i_layer.html#EventsInGUILayer">Events in GUI Layer</a>.</p>
<h2 class="doxsection"><a class="anchor" id="ReceivingModeEvents"></a>
Receiving Events</h2>
<p>Pinball gameplay modes are generally event driven in that gameplay doesn't advance until a specific sequence of events (e.g. switch events or timer events) occurs. Similarly, the modes that make up a pinball application don't advance until they receive events.</p>
<p>The P3 framework supports 4 different types of events in Modes.</p><ul>
<li><b>Switch</b> <b>Events:</b> The result of a physical switch being activated or de-activated. Modes can subscribe to switch events simply by having methods named as follows: <div class="fragment"><div class="line">// Called when swName changes state to active.  The parameter will always be a &quot;Switch&quot; object.</div>
<div class="line">public bool sw_swName_active(Switch sw)</div>
<div class="line"> </div>
<div class="line">// Called when swName changes state to inactive</div>
<div class="line">public bool sw_swName_inactive(Switch sw)</div>
<div class="line"> </div>
<div class="line">// Called when swName remains active for 2 seconds.  Any value of seconds would work.</div>
<div class="line">public bool sw_swName_active_for_2s(Switch sw)</div>
<div class="line"> </div>
<div class="line">// Called when swName remains active for 250 milliseconds.  Any value of milliseconds would work.</div>
<div class="line">public bool sw_swName_active_for_250ms(Switch sw)</div>
</div><!-- fragment --> Modes can also subscribe to switch events programmatically as follows: <div class="fragment"><div class="line">// Subscribe to swName activations immediately (0).</div>
<div class="line">add_switch_handler(swName, &quot;active&quot;, 0, SwitchHandler);</div>
<div class="line"> </div>
<div class="line">private bool SwitchHandler(Switch sw)</div>
</div><!-- fragment --></li>
<li><b>Timer</b> <b>Events:</b> Modes can have specific methods called after specified amounts of time as follows: <div class="fragment"><div class="line">private void SetupTimedCall()</div>
<div class="line">{</div>
<div class="line">    // Set up a timer called &quot;TimerName&quot; to call the method &quot;TimedCall&quot; after 1.0 seconds.</div>
<div class="line">    delay(&quot;TimerName&quot;, NetProc.EventType.None, 1.0, new P3.VoidDelegateNoArgs(TimedCall));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private void TimedCall()</div>
<div class="line">{</div>
<div class="line">    // Do Something</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private void CancelTimedCall()</div>
<div class="line">{</div>
<div class="line">    // If you want to abort the timed call, simply cancel the delay event like this:</div>
<div class="line">    cancel_delayed(&quot;TimerName&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --> Timer calls can optionally have a single parameter (to pass more parameters, create a class to hold them and pass in an instantiated object) <div class="fragment"><div class="line">private void SetupTimedCallWithParam()</div>
<div class="line">{</div>
<div class="line">    int param = 3;</div>
<div class="line">    // Set up a timer called &quot;TimerName&quot; to call the method &quot;TimedCall&quot; after 1.0 seconds.</div>
<div class="line">    delay(&quot;TimerName&quot;, NetProc.EventType.None, 1.0, new P3.VoidDelegateOneObjectArg(TimedCall), param);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">private void TimedCall(object param)</div>
<div class="line">{</div>
<div class="line">    int convertedParam = (int)param;</div>
<div class="line">    // Do Something</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>GUI</b> <b>Events:</b> GUI events are events that are initiated by GUI scripts. They are the mechanism through which the GUI can communicate with and send information to active modes. Once a GUI event handler is added, it remains active for as long as the mode remains active or until the event handler is removed. <br  />
 <div class="fragment"><div class="line">// Subcribe to the GUI event &quot;Evt_GUIEventName&quot; so that GUIEvtHandler is called when the event occurs</div>
<div class="line">// Note, the GUIEvtHandler will only be called while the mode is active.</div>
<div class="line">AddGUIEventHandler(&quot;Evt_GUIEventName&quot;, GUIEvtHandler);</div>
<div class="line"> </div>
<div class="line">private void GUIEvtHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Handler call, cast evtData to desired type if you want to use it.</div>
<div class="line">    int data = (int)evtData;</div>
<div class="line"> </div>
<div class="line">    // Do Something</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">// Unsubcribe to the GUI event &quot;Evt_GUIEventName&quot; so that GUIEvtHandler is no longer called when the event occurs.</div>
<div class="line">// This is typically only used when a mode is still active but shouldn&#39;t respond to specific events anymore.</div>
<div class="line">RemoveGUIEventHandler(&quot;Evt_GUIEventName&quot;, GUIEvtHandler);</div>
</div><!-- fragment --></li>
<li><b>Mode</b> <b>Events</b> Mode events are very similar to GUI events, except that they come from other modes. They also include a priority so that higher priority modes are given a chance to respond to the event before lower priority modes. Furthermore, a higher priority mode can choose to stop the propagation of the event to lower modes. Similar to GUI event handlers, mode event handlers remain active while the mode is active, unless the handler is specifically removed before the mode is removed from the mode queue. <br  />
 <div class="fragment"><div class="line">// Subcribe to the Mode event &quot;Evt_ModeEventName&quot; so that EvtHandler is called when the event occurs.</div>
<div class="line">// Mode events are priority based (highest priority handlers are called first).  So send in the mode&#39;s Priority when adding the handler.</div>
<div class="line">// Note - this call can be made at any time.  Putting it in the constructor ensures it is always active while the mode is active.</div>
<div class="line">AddModeEventHandler(&quot;Evt_ModeEventName&quot;, ModeEvtHandler, Priority);</div>
<div class="line"> </div>
<div class="line">private bool ModeEvtHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    // Handler call, cast evtData to desired type if you want to use it.</div>
<div class="line">    int data = (int)evtData;</div>
<div class="line"> </div>
<div class="line">    // Do Something</div>
<div class="line"> </div>
<div class="line">    // Return EVENT_CONTINUE to allow the event to propagate to other (lower priority) handlers or EVENT_STOP to stop propagation here.</div>
<div class="line">    return EVENT_CONTINUE;</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">// Unsubcribe to the Mode event &quot;Evt_ModeEventName&quot; so that ModeEvtHandler is no longer called when the event occurs.</div>
<div class="line">// This is typically only used when a mode is still active but shouldn&#39;t respond to specific events anymore.</div>
<div class="line">RemoveModeEventHandler(&quot;Evt_ModeEventName&quot;, ModeEvtHandler, Priority);</div>
</div><!-- fragment --></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="SendingModeEvents"></a>
Sending Mode Events</h2>
<p>Events can be sent from a mode to one or more other modes by posting it as follows. Data can be any type of data. Event handlers need to cast the information back to the desired type. </p><div class="fragment"><div class="line">PostModeEventToModes(&quot;Evt_EventForModes&quot;, data);</div>
</div><!-- fragment --><p>Events can be sent from a mode to a GUI script by posting it as follows: </p><div class="fragment"><div class="line">PostModeEventToGUI(&quot;Evt_EventForGUI&quot;, data);</div>
</div><!-- fragment --><p>Note - To send the same event data to both Mode and GUI, two separate Posts are required, one PostModeEventToModes and one PostModeEventToGUI.</p>
<h2 class="doxsection"><a class="anchor" id="RemovingEvents"></a>
Query/Response Events</h2>
<p>It is possible to emulate a function returning a value using two events. The first event queries for the value. The target Mode receives that event and reacts by sending a response event. The return value is the event argument of the second event. Since the event handlers of Mode-to-Mode events are executed before PostModeToModes() returns, the return value will be available right after the first Post call. The response event handler is only needed for a short time, it can be removed as soon as the response is received.</p>
<p>This is an example using a real event supported by the framework: </p><div class="fragment"><div class="line">int numWarnings = 0;  // a class member variable</div>
<div class="line"> </div>
<div class="line">AddModeEventHandler(&quot;Evt_TiltWarningCountResponse&quot;, TiltWarningCountResponseEventHandler, Priority);</div>
<div class="line">PostModeEventToModes(&quot;Evt_GetTiltWarnings&quot;, null);</div>
<div class="line">// numWarnings already holds the return value here</div>
<div class="line"> </div>
<div class="line">private bool TiltWarningCountResponseEventHandler(string evtName, object evtData){</div>
<div class="line">    numWarnings = (int)evtData;</div>
<div class="line">    RemoveModeEventHandler(&quot;Evt_TiltWarningCountResponse&quot;, TiltWarningCountResponseEventHandler);</div>
<div class="line">    return EVENT_STOP;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is an example how the framework might have implemented the "Evt_GetTiltWarnings" event: </p><div class="fragment"><div class="line">int warningCount; // a class member variable</div>
<div class="line"> </div>
<div class="line">AddModeEventHandler(&quot;Evt_GetTiltWarnings&quot;, GetTiltWarningsEventHandler, Priority);</div>
<div class="line"> </div>
<div class="line">private bool GetTiltWarningsEventHandler(string evtName, object evtData)</div>
<div class="line">{</div>
<div class="line">    PostModeEventToModes(&quot;Evt_TiltWarningCountResponse&quot;, warningCount);</div>
<div class="line">    return EVENT_STOP;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="DebuggingEvents"></a>
Debugging Events</h2>
<p>Event debugging will show which class posts the event and when, and it will show who handles the event. In the case of a switch event or a ModeToMode event, both of which propagate through the priority-based mode queue, the logging information will show all of the modes that handle the event before its propagation is stopped by a mode returning SWITCH_STOP or EVENT_STOP.</p>
<div class="fragment"><div class="line">// * Switch events *</div>
<div class="line">// The following will add the launch button (Switch name: &quot;launch&quot;) to the event logging list.</div>
<div class="line">// Any time the launch button is activated or deactivated, the system will log the sequence of modes that</div>
<div class="line">// are given the chance to process the event.</div>
<div class="line">Multimorphic.NetProcMachine.Logging.Logger.AddSwitchName(&quot;launch&quot;);</div>
<div class="line"> </div>
<div class="line">// * Mode to Mode events *</div>
<div class="line">// The following will add mode to mode events to the logging list</div>
<div class="line">Multimorphic.NetProcMachine.EventManager.LogEventName(&quot;Evt_MagnetRingCatch&quot;, true);</div>
<div class="line"> </div>
<div class="line">// * Mode to GUI events *</div>
<div class="line">// The following will add mode to GUI events to the logging list</div>
<div class="line">p3.ModesToGUIEventManager.LogEventName(&quot;Evt_ShowGUIObject&quot;, true);</div>
<div class="line"> </div>
<div class="line">// * GUI to Mode events *</div>
<div class="line">// The following will add GUI to mode events to the logging list</div>
<div class="line">p3.GUIToModesEventManager.LogEventName(&quot;Evt_SceneGoneLive&quot;, true);</div>
</div><!-- fragment --><p>More mode information:</p><ul>
<li><a class="el" href="_player_data.html">Player Data</a></li>
<li><a class="el" href="_persistent_data.html">Persistent Data</a></li>
<li><a class="el" href="_customizing_your_game.html#GameManagement">Game Management</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
